package com.basebackend.scheduler.workflow;

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Deque;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.function.Predicate;

/**
 * DAG 拓扑排序工具，基于 Kahn 算法实现，支持条件边过滤与并行批次识别。
 */
public final class TopologicalSorter {

    private TopologicalSorter() {
    }

    /**
     * 使用所有边执行拓扑排序。
     *
     * @param nodes 节点集合
     * @param edges 边集合
     * @return 排序结果
     */
    public static Result sort(Map<String, WorkflowNode> nodes, List<WorkflowEdge> edges) {
        return sort(nodes, edges, edge -> true);
    }

    /**
     * 支持条件过滤的拓扑排序。
     *
     * @param nodes         节点集合
     * @param edges         边集合
     * @param edgeSelector  条件边选择器，返回 true 则参与排序
     * @return 排序结果
     */
    public static Result sort(Map<String, WorkflowNode> nodes,
                              List<WorkflowEdge> edges,
                              Predicate<WorkflowEdge> edgeSelector) {
        Objects.requireNonNull(nodes, "nodes");
        Objects.requireNonNull(edges, "edges");
        Objects.requireNonNull(edgeSelector, "edgeSelector");

        Map<String, Integer> inDegree = initInDegree(nodes);
        Map<String, List<String>> adjacency = initAdjacency(nodes);

        for (WorkflowEdge edge : edges) {
            if (!edgeSelector.test(edge)) {
                continue;
            }
            if (!nodes.containsKey(edge.getFrom()) || !nodes.containsKey(edge.getTo())) {
                throw new IllegalStateException("Edge references unknown node: " + edge.getFrom() + " -> " + edge.getTo());
            }
            adjacency.get(edge.getFrom()).add(edge.getTo());
            inDegree.put(edge.getTo(), inDegree.get(edge.getTo()) + 1);
        }

        Deque<String> queue = new ArrayDeque<>();
        inDegree.forEach((nodeId, degree) -> {
            if (degree == 0) {
                queue.add(nodeId);
            }
        });

        List<String> ordered = new ArrayList<>(nodes.size());
        List<List<String>> parallelLayers = new ArrayList<>();

        while (!queue.isEmpty()) {
            int batchSize = queue.size();
            List<String> batch = new ArrayList<>(batchSize);
            for (int i = 0; i < batchSize; i++) {
                String nodeId = queue.removeFirst();
                ordered.add(nodeId);
                batch.add(nodeId);
                for (String next : adjacency.get(nodeId)) {
                    int newDegree = inDegree.compute(next, (key, value) -> value - 1);
                    if (newDegree == 0) {
                        queue.addLast(next);
                    }
                }
            }
            parallelLayers.add(Collections.unmodifiableList(batch));
        }

        boolean hasCycle = ordered.size() != nodes.size();
        List<String> unresolvedNodes = hasCycle ? findUnresolvedNodes(inDegree, ordered) : Collections.emptyList();
        return new Result(ordered, parallelLayers, hasCycle, unresolvedNodes);
    }

    private static Map<String, Integer> initInDegree(Map<String, WorkflowNode> nodes) {
        Map<String, Integer> inDegree = new LinkedHashMap<>();
        for (String nodeId : nodes.keySet()) {
            inDegree.put(nodeId, 0);
        }
        return inDegree;
    }

    private static Map<String, List<String>> initAdjacency(Map<String, WorkflowNode> nodes) {
        Map<String, List<String>> adjacency = new HashMap<>();
        for (String nodeId : nodes.keySet()) {
            adjacency.put(nodeId, new ArrayList<>());
        }
        return adjacency;
    }

    private static List<String> findUnresolvedNodes(Map<String, Integer> inDegree, List<String> ordered) {
        Set<String> visited = new LinkedHashSet<>(ordered);
        List<String> unresolved = new ArrayList<>();
        inDegree.forEach((node, degree) -> {
            if (!visited.contains(node) && degree > 0) {
                unresolved.add(node);
            }
        });
        return Collections.unmodifiableList(unresolved);
    }

    /**
     * 排序结果，包含拓扑序、并行批次与循环标识。
     */
    public static final class Result {
        private final List<String> orderedNodes;
        private final List<List<String>> parallelLayers;
        private final boolean hasCycle;
        private final List<String> unresolvedNodes;

        Result(List<String> orderedNodes, List<List<String>> parallelLayers, boolean hasCycle, List<String> unresolvedNodes) {
            this.orderedNodes = Collections.unmodifiableList(new ArrayList<>(orderedNodes));
            this.parallelLayers = Collections.unmodifiableList(new ArrayList<>(parallelLayers));
            this.hasCycle = hasCycle;
            this.unresolvedNodes = unresolvedNodes;
        }

        /**
         * 拓扑序列。
         */
        public List<String> getOrderedNodes() {
            return orderedNodes;
        }

        /**
         * 按批次分组的可并行节点列表。
         */
        public List<List<String>> getParallelLayers() {
            return parallelLayers;
        }

        /**
         * 是否存在环。
         */
        public boolean hasCycle() {
            return hasCycle;
        }

        /**
         * 形成环的节点集合。
         */
        public List<String> getUnresolvedNodes() {
            return unresolvedNodes;
        }

        /**
         * 返回首批可立即执行的节点集合。
         *
         * @return 首批节点
         */
        public List<String> getReadyNodes() {
            return parallelLayers.isEmpty() ? Collections.emptyList() : parallelLayers.get(0);
        }
    }
}
