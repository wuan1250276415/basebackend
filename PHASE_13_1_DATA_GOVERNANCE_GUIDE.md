# Phase 13.1: æ•°æ®æ²»ç†å¹³å°å®æ–½æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•æ„å»ºä¼ä¸šçº§æ•°æ®æ²»ç†å¹³å°ï¼Œå®ç°å…ƒæ•°æ®ç®¡ç†ã€æ•°æ®è´¨é‡ç®¡ç†ã€æ•°æ®è¡€ç¼˜è¿½è¸ªå’Œæ•æ„Ÿæ•°æ®ä¿æŠ¤ï¼Œæ„å»ºå¯ä¿¡èµ–çš„æ•°æ®èµ„äº§ç®¡ç†ä½“ç³»ã€‚

---

## ğŸ—ï¸ æ•°æ®æ²»ç†å¹³å°æ¶æ„

### æ•´ä½“æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ•°æ®æ²»ç†å¹³å°æ¶æ„                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   å…ƒæ•°æ®ç®¡ç†   â”‚  â”‚   æ•°æ®è´¨é‡    â”‚  â”‚   æ•°æ®è¡€ç¼˜    â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ æ•°æ®èµ„äº§     â”‚  â”‚ â€¢ è´¨é‡è§„åˆ™     â”‚  â”‚ â€¢ è¡€ç¼˜åˆ†æ     â”‚           â”‚
â”‚  â”‚ â€¢ ä¸šåŠ¡æœ¯è¯­     â”‚  â”‚ â€¢ è´¨é‡æ£€æµ‹     â”‚  â”‚ â€¢ å½±å“åˆ†æ     â”‚           â”‚
â”‚  â”‚ â€¢ æŠ€æœ¯å…ƒæ•°æ®   â”‚  â”‚ â€¢ è´¨é‡æŠ¥å‘Š     â”‚  â”‚ â€¢ å˜æ›´ä¼ æ’­     â”‚           â”‚
â”‚  â”‚ â€¢ æ•°æ®æ ‡ç­¾     â”‚  â”‚ â€¢ å¼‚å¸¸å‘Šè­¦     â”‚  â”‚ â€¢ è¡€ç¼˜å¯è§†åŒ–   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   æ•°æ®å®‰å…¨     â”‚  â”‚   æ•°æ®æ ‡å‡†   â”‚  â”‚   æ•°æ®æœåŠ¡   â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ æ•°æ®åˆ†çº§     â”‚  â”‚ â€¢ æ ‡å‡†è§„èŒƒ     â”‚  â”‚ â€¢ æ•°æ®API    â”‚           â”‚
â”‚  â”‚ â€¢ æ•æ„Ÿæ•°æ®     â”‚  â”‚ â€¢ å…ƒæ•°æ®æ ‡å‡†   â”‚  â”‚ â€¢ æ•°æ®ç›®å½•     â”‚           â”‚
â”‚  â”‚ â€¢ è®¿é—®æ§åˆ¶     â”‚  â”‚ â€¢ æ•°æ®æ¨¡å‹     â”‚  â”‚ â€¢ æ•°æ®æ£€ç´¢     â”‚           â”‚
â”‚  â”‚ â€¢ å®¡è®¡æ—¥å¿—     â”‚  â”‚ â€¢ å‘½åè§„èŒƒ     â”‚  â”‚ â€¢ è‡ªåŠ©åˆ†æ     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    æ•°æ®å­˜å‚¨å±‚                                 â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ â€¢ PostgreSQL (å…ƒæ•°æ®å­˜å‚¨)                                     â”‚ â”‚
â”‚  â”‚ â€¢ Elasticsearch (æœç´¢å¼•æ“)                                    â”‚ â”‚
â”‚  â”‚ â€¢ Neo4j (è¡€ç¼˜å›¾æ•°æ®åº“)                                        â”‚ â”‚
â”‚  â”‚ â€¢ MinIO (æ–‡æ¡£å­˜å‚¨)                                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    é‡‡é›†ä¸å¤„ç†å±‚                                â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ â€¢ DataX (æ•°æ®åŒæ­¥)                                            â”‚ â”‚
â”‚  â”‚ â€¢ Flink CDC (å˜æ›´æ•è·)                                        â”‚ â”‚
â”‚  â”‚ â€¢è‡ªå®šä¹‰æ‰«æå™¨ (å…ƒæ•°æ®æŠ½å–)                                     â”‚ â”‚
â”‚  â”‚ â€¢ å®šæ—¶ä»»åŠ¡è°ƒåº¦ (XXL-Job)                                      â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æ ¸å¿ƒæŠ€æœ¯æ ˆ

| ç»„ä»¶ | ç”¨é€” | ç‰ˆæœ¬ |
|------|------|------|
| **Apache Atlas** | å…ƒæ•°æ®ç®¡ç† | 2.3.0 |
| **DataHub** | å…ƒæ•°æ®å¹³å° | 0.10.0 |
| **Apache Griffin** | æ•°æ®è´¨é‡ | 0.7.0 |
| **Elasticsearch** | æœç´¢å¼•æ“ | 8.11.0 |
| **Neo4j** | å›¾æ•°æ®åº“ | 5.15.0 |
| **Apache Flink** | å®æ—¶å¤„ç† | 1.18.0 |
| **DataX** | æ•°æ®åŒæ­¥ | 3.0 |
| **XXL-Job** | ä»»åŠ¡è°ƒåº¦ | 2.4.0 |

---

## ğŸ“¦ å…ƒæ•°æ®ç®¡ç†

### 1. å…ƒæ•°æ®æ¨¡å‹è®¾è®¡

```java
/**
 * å…ƒæ•°æ®å®ä½“å®šä¹‰
 */

/**
 * æ•°æ®è¡¨å…ƒæ•°æ®
 */
@Entity
@Table(name = "dg_table_metadata")
@Data
@EqualsAndHashCode(callSuper = true)
public class TableMetadata extends BaseEntity {

    /**
     * è¡¨åç§°
     */
    @Column(name = "table_name", nullable = false, length = 100)
    private String tableName;

    /**
     * è¡¨æ³¨é‡Š
     */
    @Column(name = "table_comment", length = 500)
    private String tableComment;

    /**
     * æ•°æ®åº“åç§°
     */
    @Column(name = "database_name", nullable = false, length = 100)
    private String databaseName;

    /**
     * æ•°æ®æºID
     */
    @Column(name = "datasource_id")
    private Long datasourceId;

    /**
     * è¡¨ç±»å‹ (TABLE/VIEW)
     */
    @Column(name = "table_type", length = 20)
    private String tableType;

    /**
     * è¡Œæ•°
     */
    @Column(name = "row_count")
    private Long rowCount;

    /**
     * è¡¨å¤§å° (å­—èŠ‚)
     */
    @Column(name = "table_size")
    private Long tableSize;

    /**
     * åˆ›å»ºæ—¶é—´
     */
    @Column(name = "create_time")
    private Date createTime;

    /**
     * æœ€åæ›´æ–°æ—¶é—´
     */
    @Column(name = "last_update_time")
    private Date lastUpdateTime;

    /**
     * æ•°æ®æ‰€æœ‰è€…
     */
    @Column(name = "owner", length = 100)
    private String owner;

    /**
     * ä¸šåŠ¡Owner
     */
    @Column(name = "business_owner", length = 100)
    private String businessOwner;

    /**
     * æŠ€æœ¯Owner
     */
    @Column(name = "technical_owner", length = 100)
    private String technicalOwner;

    /**
     * æ•°æ®åˆ†çº§ (PUBLIC/INTERNAL/CONFIDENTIAL/SECRET)
     */
    @Column(name = "data_classification", length = 20)
    private String dataClassification;

    /**
     * çŠ¶æ€ (ACTIVE/INACTIVE/DEPRECATED)
     */
    @Column(name = "status", length = 20)
    private String status;

    /**
     * è¡¨å­—æ®µåˆ—è¡¨
     */
    @OneToMany(mappedBy = "tableMetadata", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
    private List<ColumnMetadata> columns;

    /**
     * æ ‡ç­¾
     */
    @ManyToMany
    @JoinTable(name = "dg_table_tags",
        joinColumns = @JoinColumn(name = "table_id"),
        inverseJoinColumns = @JoinColumn(name = "tag_id"))
    private Set<Tag> tags;
}

/**
 * å­—æ®µå…ƒæ•°æ®
 */
@Entity
@Table(name = "dg_column_metadata")
@Data
@EqualsAndHashCode(callSuper = true)
public class ColumnMetadata extends BaseEntity {

    /**
     * æ‰€å±è¡¨
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "table_id")
    private TableMetadata tableMetadata;

    /**
     * å­—æ®µåç§°
     */
    @Column(name = "column_name", nullable = false, length = 100)
    private String columnName;

    /**
     * å­—æ®µæ³¨é‡Š
     */
    @Column(name = "column_comment", length = 500)
    private String columnComment;

    /**
     * æ•°æ®ç±»å‹
     */
    @Column(name = "data_type", nullable = false, length = 100)
    private String dataType;

    /**
     * å­—æ®µé•¿åº¦
     */
    @Column(name = "column_size")
    private Integer columnSize;

    /**
     * å°æ•°ä½
     */
    @Column(name = "decimal_digits")
    private Integer decimalDigits;

    /**
     * æ˜¯å¦å¯ç©º
     */
    @Column(name = "nullable")
    private Boolean nullable;

    /**
     * é»˜è®¤å€¼
     */
    @Column(name = "default_value", length = 500)
    private String defaultValue;

    /**
     * æ˜¯å¦ä¸»é”®
     */
    @Column(name = "is_primary_key")
    private Boolean isPrimaryKey;

    /**
     * æ˜¯å¦å¤–é”®
     */
    @Column(name = "is_foreign_key")
    private Boolean isForeignKey;

    /**
     * å­—æ®µåºå·
     */
    @Column(name = "ordinal_position")
    private Integer ordinalPosition;

    /**
     * ç»Ÿè®¡ä¿¡æ¯
     */
    @Embedded
    private ColumnStatistics statistics;
}

/**
 * æ•°æ®æºå…ƒæ•°æ®
 */
@Entity
@Table(name = "dg_datasource")
@Data
@EqualsAndHashCode(callSuper = true)
public class DataSource extends BaseEntity {

    /**
     * æ•°æ®æºåç§°
     */
    @Column(name = "datasource_name", nullable = false, length = 100)
    private String datasourceName;

    /**
     * æ•°æ®æºç±»å‹ (MySQL/PostgreSQL/Oracle/SQLServer/MongoDB/Elasticsearchç­‰)
     */
    @Column(name = "datasource_type", length = 50)
    private String datasourceType;

    /**
     * è¿æ¥åœ°å€
     */
    @Column(name = "connection_url", length = 500)
    private String connectionUrl;

    /**
     * ç”¨æˆ·å
     */
    @Column(name = "username", length = 100)
    private String username;

    /**
     * å¯†ç (åŠ å¯†)
     */
    @Column(name = "password", length = 500)
    private String password;

    /**
     * è¿æ¥å‚æ•°(JSON)
     */
    @Column(name = "connection_params", columnDefinition = "TEXT")
    private String connectionParams;

    /**
     * æè¿°
     */
    @Column(name = "description", length = 500)
    private String description;

    /**
     * çŠ¶æ€
     */
    @Column(name = "status", length = 20)
    private String status;
}

/**
 * æ ‡ç­¾
 */
@Entity
@Table(name = "dg_tag")
@Data
@EqualsAndHashCode(callSuper = true)
public class Tag extends BaseEntity {

    /**
     * æ ‡ç­¾åç§°
     */
    @Column(name = "tag_name", nullable = false, length = 50)
    private String tagName;

    /**
     * æ ‡ç­¾æè¿°
     */
    @Column(name = "tag_description", length = 500)
    private String tagDescription;

    /**
     * æ ‡ç­¾é¢œè‰²
     */
    @Column(name = "color", length = 20)
    private String color;

    /**
     * æ ‡ç­¾åˆ†ç±»
     */
    @Column(name = "category", length = 50)
    private String category;
}

/**
 * ä¸šåŠ¡æœ¯è¯­
 */
@Entity
@Table(name = "dg_business_term")
@Data
@EqualsAndHashCode(callSuper = true)
public class BusinessTerm extends BaseEntity {

    /**
     * æœ¯è¯­åç§°
     */
    @Column(name = "term_name", nullable = false, length = 100)
    private String termName;

    /**
     * æœ¯è¯­å®šä¹‰
     */
    @Column(name = "definition", columnDefinition = "TEXT")
    private String definition;

    /**
     * ä¸šåŠ¡å£å¾„
     */
    @Column(name = "business_rules", columnDefinition = "TEXT")
    private String businessRules;

    /**
     * ç›¸å…³æ•°æ®é¡¹
     */
    @ManyToMany
    @JoinTable(name = "dg_term_columns",
        joinColumns = @JoinColumn(name = "term_id"),
        inverseJoinColumns = @JoinColumn(name = "column_id"))
    private Set<ColumnMetadata> relatedColumns;

    /**
     * çŠ¶æ€
     */
    @Column(name = "status", length = 20)
    private String status;
}
```

### 2. å…ƒæ•°æ®æ‰«ææœåŠ¡

```java
/**
 * å…ƒæ•°æ®æ‰«ææœåŠ¡
 */
@Service
public class MetadataScannerService {

    private static final Logger logger = LoggerFactory.getLogger(MetadataScannerService.class);

    @Autowired
    private DataSourceMapper dataSourceMapper;

    @Autowired
    private TableMetadataMapper tableMetadataMapper;

    @Autowired
    private ColumnMetadataMapper columnMetadataMapper;

    /**
     * æ‰«ææ•°æ®æºçš„æ‰€æœ‰è¡¨
     */
    @Transactional
    public void scanDataSource(Long datasourceId) {
        DataSource dataSource = dataSourceMapper.selectById(datasourceId);
        if (dataSource == null) {
            throw new BusinessException("æ•°æ®æºä¸å­˜åœ¨");
        }

        logger.info("å¼€å§‹æ‰«ææ•°æ®æº: {}", dataSource.getDatasourceName());

        try (Connection conn = getConnection(dataSource)) {
            DatabaseMetaData metaData = conn.getMetaData();

            // è·å–æ‰€æœ‰è¡¨
            ResultSet tables = metaData.getTables(
                conn.getCatalog(),
                null,
                null,
                new String[]{"TABLE", "VIEW"}
            );

            while (tables.next()) {
                scanTable(conn, metaData, dataSource, tables);
            }

        } catch (Exception e) {
            logger.error("æ‰«ææ•°æ®æºå¤±è´¥", e);
            throw new BusinessException("æ‰«ææ•°æ®æºå¤±è´¥: " + e.getMessage());
        }

        logger.info("æ•°æ®æºæ‰«æå®Œæˆ: {}", dataSource.getDatasourceName());
    }

    /**
     * æ‰«æå•ä¸ªè¡¨
     */
    private void scanTable(Connection conn, DatabaseMetaData metaData,
                          DataSource dataSource, ResultSet tables) throws SQLException {
        String tableName = tables.getString("TABLE_NAME");
        String tableComment = tables.getString("REMARKS");
        String tableType = tables.getString("TABLE_TYPE");

        // æ£€æŸ¥è¡¨æ˜¯å¦å·²å­˜åœ¨
        TableMetadata tableMetadata = tableMetadataMapper.findByName(
            dataSource.getDatabaseName(), tableName);

        if (tableMetadata == null) {
            tableMetadata = new TableMetadata();
            tableMetadata.setDatabaseName(dataSource.getDatabaseName());
            tableMetadata.setTableName(tableName);
            tableMetadata.setTableComment(tableComment);
            tableMetadata.setTableType(tableType);
            tableMetadata.setDatasourceId(dataSource.getId());
            tableMetadata.setStatus("ACTIVE");
            tableMetadata.setCreateTime(new Date());
            tableMetadataMapper.insert(tableMetadata);
        }

        // æ›´æ–°è¡¨ç»Ÿè®¡ä¿¡æ¯
        updateTableStatistics(conn, tableMetadata);

        // æ‰«æå­—æ®µ
        scanColumns(metaData, tableMetadata);
    }

    /**
     * æ‰«æè¡¨å­—æ®µ
     */
    private void scanColumns(DatabaseMetaData metaData, TableMetadata tableMetadata)
            throws SQLException {

        // åˆ é™¤æ—§å­—æ®µ
        columnMetadataMapper.deleteByTableId(tableMetadata.getId());

        // è·å–å­—æ®µä¿¡æ¯
        ResultSet columns = metaData.getColumns(
            null,
            null,
            tableMetadata.getTableName(),
            null
        );

        while (columns.next()) {
            ColumnMetadata columnMetadata = new ColumnMetadata();
            columnMetadata.setTableMetadata(tableMetadata);
            columnMetadata.setColumnName(columns.getString("COLUMN_NAME"));
            columnMetadata.setColumnComment(columns.getString("REMARKS"));
            columnMetadata.setDataType(columns.getString("TYPE_NAME"));
            columnMetadata.setColumnSize(columns.getInt("COLUMN_SIZE"));
            columnMetadata.setDecimalDigits(columns.getInt("DECIMAL_DIGITS"));
            columnMetadata.setNullable("YES".equals(columns.getString("IS_NULLABLE")));
            columnMetadata.setDefaultValue(columns.getString("COLUMN_DEF"));
            columnMetadata.setOrdinalPosition(columns.getInt("ORDINAL_POSITION"));

            columnMetadataMapper.insert(columnMetadata);
        }
    }

    /**
     * æ›´æ–°è¡¨ç»Ÿè®¡ä¿¡æ¯
     */
    private void updateTableStatistics(Connection conn, TableMetadata tableMetadata)
            throws SQLException {

        String sql = "SELECT COUNT(*) FROM " + tableMetadata.getDatabaseName() + "." +
                    tableMetadata.getTableName();

        try (PreparedStatement stmt = conn.prepareStatement(sql);
             ResultSet rs = stmt.executeQuery()) {

            if (rs.next()) {
                tableMetadata.setRowCount(rs.getLong(1));
            }
        }

        tableMetadata.setLastUpdateTime(new Date());
        tableMetadataMapper.updateById(tableMetadata);
    }

    /**
     * è·å–æ•°æ®åº“è¿æ¥
     */
    private Connection getConnection(DataSource dataSource) throws Exception {
        Properties props = new Properties();
        props.put("driver", dataSource.getDatasourceType());

        if (StringUtils.hasText(dataSource.getUsername())) {
            props.put("user", dataSource.getUsername());
        }
        if (StringUtils.hasText(dataSource.getPassword())) {
            props.put("password", dataSource.getPassword());
        }

        if (StringUtils.hasText(dataSource.getConnectionParams())) {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, String> params = mapper.readValue(
                dataSource.getConnectionParams(), Map.class);
            props.putAll(params);
        }

        return DriverManager.getConnection(dataSource.getConnectionUrl(), props);
    }
}

/**
 * å…ƒæ•°æ®é‡‡é›†ä»»åŠ¡
 */
@Component
public class MetadataScanJob {

    private static final Logger logger = LoggerFactory.getLogger(MetadataScanJob.class);

    @Autowired
    private MetadataScannerService scannerService;

    @Autowired
    private DataSourceMapper dataSourceMapper;

    /**
     * æ‰«ææ‰€æœ‰æ•°æ®æº
     */
    @XxlJob("scanAllDataSources")
    public void scanAllDataSources() {
        logger.info("å¼€å§‹æ‰§è¡Œå…¨é‡å…ƒæ•°æ®æ‰«æä»»åŠ¡");

        try {
            List<DataSource> dataSources = dataSourceMapper.selectList(
                new QueryWrapper<DataSource>().eq("status", "ACTIVE"));

            for (DataSource dataSource : dataSources) {
                try {
                    scannerService.scanDataSource(dataSource.getId());
                    logger.info("æ•°æ®æºæ‰«æå®Œæˆ: {}", dataSource.getDatasourceName());
                } catch (Exception e) {
                    logger.error("æ•°æ®æºæ‰«æå¤±è´¥: {}", dataSource.getDatasourceName(), e);
                }
            }

            logger.info("å…¨é‡å…ƒæ•°æ®æ‰«æä»»åŠ¡å®Œæˆ");
        } catch (Exception e) {
            logger.error("å…¨é‡å…ƒæ•°æ®æ‰«æä»»åŠ¡å¤±è´¥", e);
        }
    }

    /**
     * å¢é‡æ‰«æ(åŸºäºæ—¶é—´æˆ³)
     */
    @XxlJob("incrementalScan")
    public void incrementalScan() {
        logger.info("å¼€å§‹æ‰§è¡Œå¢é‡å…ƒæ•°æ®æ‰«æä»»åŠ¡");

        // å®ç°åŸºäºæ—¶é—´æˆ³çš„å¢é‡æ‰«æé€»è¾‘
        // ...
    }
}
```

### 3. å…ƒæ•°æ®APIæœåŠ¡

```java
/**
 * å…ƒæ•°æ®ç®¡ç†API
 */
@RestController
@RequestMapping("/api/metadata")
@Api(tags = "å…ƒæ•°æ®ç®¡ç†")
public class MetadataController {

    @Autowired
    private MetadataScannerService scannerService;

    @Autowired
    private TableMetadataMapper tableMetadataMapper;

    @Autowired
    private ColumnMetadataMapper columnMetadataMapper;

    /**
     * è·å–è¡¨åˆ—è¡¨
     */
    @GetMapping("/tables")
    @ApiOperation("è·å–è¡¨åˆ—è¡¨")
    public Result<Page<TableMetadata>> getTables(
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "20") Integer size,
            @RequestParam(required = false) String databaseName,
            @RequestParam(required = false) String tableName,
            @RequestParam(required = false) String owner) {

        Page<TableMetadata> pageInfo = new Page<>(page, size);

        QueryWrapper<TableMetadata> wrapper = new QueryWrapper<>();

        if (StringUtils.hasText(databaseName)) {
            wrapper.like("database_name", databaseName);
        }
        if (StringUtils.hasText(tableName)) {
            wrapper.like("table_name", tableName);
        }
        if (StringUtils.hasText(owner)) {
            wrapper.like("owner", owner);
        }

        wrapper.orderByDesc("last_update_time");

        pageInfo = tableMetadataMapper.selectPage(pageInfo, wrapper);

        return Result.success(pageInfo);
    }

    /**
     * è·å–è¡¨è¯¦æƒ…
     */
    @GetMapping("/tables/{tableId}")
    @ApiOperation("è·å–è¡¨è¯¦æƒ…")
    public Result<TableMetadata> getTableDetail(@PathVariable Long tableId) {
        TableMetadata table = tableMetadataMapper.selectById(tableId);
        if (table == null) {
            return Result.error("è¡¨ä¸å­˜åœ¨");
        }

        // åŠ è½½å­—æ®µä¿¡æ¯
        List<ColumnMetadata> columns = columnMetadataMapper.selectList(
            new QueryWrapper<ColumnMetadata>().eq("table_id", tableId)
                .orderByAsc("ordinal_position"));
        table.setColumns(columns);

        return Result.success(table);
    }

    /**
     * æœç´¢è¡¨
     */
    @GetMapping("/tables/search")
    @ApiOperation("æœç´¢è¡¨")
    public Result<List<TableMetadata>> searchTables(@RequestParam String keyword) {

        QueryWrapper<TableMetadata> wrapper = new QueryWrapper<>();
        wrapper.and(w -> w.like("table_name", keyword)
            .or().like("table_comment", keyword)
            .or().like("owner", keyword));

        List<TableMetadata> tables = tableMetadataMapper.selectList(wrapper);

        return Result.success(tables);
    }

    /**
     * æ‰‹åŠ¨è§¦å‘æ‰«æ
     */
    @PostMapping("/scan/{datasourceId}")
    @ApiOperation("æ‰‹åŠ¨è§¦å‘æ‰«æ")
    public Result<Void> triggerScan(@PathVariable Long datasourceId) {
        scannerService.scanDataSource(datasourceId);
        return Result.success();
    }

    /**
     * è·å–æ•°æ®è¡€ç¼˜å…³ç³»
     */
    @GetMapping("/lineage/{tableId}")
    @ApiOperation("è·å–æ•°æ®è¡€ç¼˜å…³ç³»")
    public Result<Map<String, Object>> getDataLineage(@PathVariable Long tableId) {
        // æŸ¥è¯¢ä¸Šæ¸¸è¡¨
        List<TableMetadata> upstreamTables = tableMetadataMapper.selectUpstreamTables(tableId);

        // æŸ¥è¯¢ä¸‹æ¸¸è¡¨
        List<TableMetadata> downstreamTables = tableMetadataMapper.selectDownstreamTables(tableId);

        Map<String, Object> result = new HashMap<>();
        result.put("upstream", upstreamTables);
        result.put("downstream", downstreamTables);

        return Result.success(result);
    }

    /**
     * æ›´æ–°è¡¨æ ‡ç­¾
     */
    @PutMapping("/tables/{tableId}/tags")
    @ApiOperation("æ›´æ–°è¡¨æ ‡ç­¾")
    public Result<Void> updateTableTags(@PathVariable Long tableId,
                                       @RequestBody Set<Tag> tags) {
        TableMetadata table = tableMetadataMapper.selectById(tableId);
        if (table == null) {
            return Result.error("è¡¨ä¸å­˜åœ¨");
        }

        table.setTags(tags);
        tableMetadataMapper.updateById(table);

        return Result.success();
    }

    /**
     * è·å–æ•°æ®æ¦‚è§ˆ
     */
    @GetMapping("/overview")
    @ApiOperation("è·å–æ•°æ®æ¦‚è§ˆ")
    public Result<Map<String, Object>> getDataOverview() {

        Map<String, Object> overview = new HashMap<>();

        // æ€»è¡¨æ•°
        Integer totalTables = tableMetadataMapper.selectCount(new QueryWrapper<>());
        overview.put("totalTables", totalTables);

        // æ•°æ®åº“æ•°
        Integer totalDatabases = tableMetadataMapper.selectObjs(
            new QueryWrapper<TableMetadata>().select("DISTINCT database_name"))
            .size();
        overview.put("totalDatabases", totalDatabases);

        // ä»Šæ—¥æ›´æ–°
        Integer todayUpdated = tableMetadataMapper.selectCount(
            new QueryWrapper<TableMetadata>()
                .ge("last_update_time", DateUtil.beginOfDay(new Date()))
                .le("last_update_time", DateUtil.endOfDay(new Date())));
        overview.put("todayUpdated", todayUpdated);

        // æ•°æ®åˆ†ç±»ç»Ÿè®¡
        Map<String, Long> classificationStats = tableMetadataMapper.selectMaps(
            new QueryWrapper<TableMetadata>()
                .select("data_classification, COUNT(*) as count")
                .groupBy("data_classification"))
            .stream()
            .collect(Collectors.toMap(
                m -> (String) m.get("data_classification"),
                m -> (Long) m.get("count")
            ));
        overview.put("classificationStats", classificationStats);

        return Result.success(overview);
    }
}
```

---

## ğŸ” æ•°æ®è´¨é‡ç®¡ç†

### 1. è´¨é‡è§„åˆ™å¼•æ“

```java
/**
 * æ•°æ®è´¨é‡è§„åˆ™
 */
@Entity
@Table(name = "dg_quality_rule")
@Data
@EqualsAndHashCode(callSuper = true)
public class QualityRule extends BaseEntity {

    /**
     * è§„åˆ™åç§°
     */
    @Column(name = "rule_name", nullable = false, length = 100)
    private String ruleName;

    /**
     * è§„åˆ™æè¿°
     */
    @Column(name = "description", length = 500)
    private String description;

    /**
     * è§„åˆ™ç±»å‹ (COMPLETENESS/ACCURACY/CONSISTENCY/TIMELINESS/UNIQUENESS/VALIDITY)
     */
    @Column(name = "rule_type", length = 50)
    private String ruleType;

    /**
     * è§„åˆ™æ¨¡æ¿
     */
    @Column(name = "rule_template", columnDefinition = "TEXT")
    private String ruleTemplate;

    /**
     * è§„åˆ™å‚æ•°(JSON)
     */
    @Column(name = "rule_params", columnDefinition = "TEXT")
    private String ruleParams;

    /**
     * ä¸¥é‡ç¨‹åº¦ (FATAL/ERROR/WARNING/INFO)
     */
    @Column(name = "severity", length = 20)
    private String severity;

    /**
     * ç›®æ ‡è¡¨ID
     */
    @Column(name = "table_id")
    private Long tableId;

    /**
     * ç›®æ ‡å­—æ®µ
     */
    @Column(name = "target_column", length = 100)
    private String targetColumn;

    /**
     * çŠ¶æ€
     */
    @Column(name = "status", length = 20)
    private String status;

    /**
     * æ‰§è¡Œé¢‘ç‡
     */
    @Column(name = "execution_frequency", length = 50)
    private String executionFrequency;
}

/**
 * æ•°æ®è´¨é‡æ£€æŸ¥ç»“æœ
 */
@Entity
@Table(name = "dg_quality_check_result")
@Data
@EqualsAndHashCode(callSuper = true)
public class QualityCheckResult extends BaseEntity {

    /**
     * è§„åˆ™ID
     */
    @Column(name = "rule_id")
    private Long ruleId;

    /**
     * æ‰§è¡Œæ—¶é—´
     */
    @Column(name = "execution_time")
    private Date executionTime;

    /**
     * æ‰§è¡ŒçŠ¶æ€ (SUCCESS/FAILED/SKIPPED)
     */
    @Column(name = "execution_status", length = 20)
    private String executionStatus;

    /**
     * æ£€æŸ¥æ€»æ•°
     */
    @Column(name = "total_count")
    private Long totalCount;

    /**
     * é€šè¿‡æ•°
     */
    @Column(name = "pass_count")
    private Long passCount;

    /**
     * å¤±è´¥æ•°
     */
    @Column(name = "fail_count")
    private Long failCount;

    /**
     * é€šè¿‡ç‡
     */
    @Column(name = "pass_rate")
    private Double passRate;

    /**
     * é”™è¯¯è¯¦æƒ…
     */
    @Column(name = "error_details", columnDefinition = "TEXT")
    private String errorDetails;

    /**
     * æ‰§è¡Œè€—æ—¶(ms)
     */
    @Column(name = "execution_duration")
    private Long executionDuration;
}

/**
 * æ•°æ®è´¨é‡è§„åˆ™å¼•æ“
 */
@Service
public class QualityRuleEngine {

    private static final Logger logger = LoggerFactory.getLogger(QualityRuleEngine.class);

    @Autowired
    private QualityRuleMapper ruleMapper;

    @Autowired
    private QualityCheckResultMapper resultMapper;

    @Autowired
    private TableMetadataMapper tableMetadataMapper;

    /**
     * æ‰§è¡Œè´¨é‡æ£€æŸ¥
     */
    @Transactional
    public QualityCheckResult executeCheck(Long ruleId) {
        QualityRule rule = ruleMapper.selectById(ruleId);
        if (rule == null) {
            throw new BusinessException("è§„åˆ™ä¸å­˜åœ¨");
        }

        QualityCheckResult result = new QualityCheckResult();
        result.setRuleId(ruleId);
        result.setExecutionTime(new Date());

        long startTime = System.currentTimeMillis();

        try {
            switch (rule.getRuleType()) {
                case "COMPLETENESS":
                    result = checkCompleteness(rule, result);
                    break;
                case "ACCURACY":
                    result = checkAccuracy(rule, result);
                    break;
                case "CONSISTENCY":
                    result = checkConsistency(rule, result);
                    break;
                case "TIMELINESS":
                    result = checkTimeliness(rule, result);
                    break;
                case "UNIQUENESS":
                    result = checkUniqueness(rule, result);
                    break;
                case "VALIDITY":
                    result = checkValidity(rule, result);
                    break;
                default:
                    throw new BusinessException("ä¸æ”¯æŒçš„è§„åˆ™ç±»å‹: " + rule.getRuleType());
            }

            result.setExecutionStatus("SUCCESS");
            result.setExecutionDuration(System.currentTimeMillis() - startTime);

        } catch (Exception e) {
            logger.error("è´¨é‡æ£€æŸ¥å¤±è´¥", e);
            result.setExecutionStatus("FAILED");
            result.setExecutionDuration(System.currentTimeMillis() - startTime);
            result.setErrorDetails(ExceptionUtils.getStackTrace(e));
        }

        resultMapper.insert(result);
        return result;
    }

    /**
     * å®Œæ•´æ€§æ£€æŸ¥
     */
    private QualityCheckResult checkCompleteness(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());
        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count, ");
        sql.append("COUNT(").append(rule.getTargetColumn()).append(") as non_null_count ");
        sql.append("FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName());

        // æ‰§è¡ŒSQLæŸ¥è¯¢
        Map<String, Object> queryResult = executeQuery(sql.toString());

        Long totalCount = ((Number) queryResult.get("total_count")).longValue();
        Long nonNullCount = ((Number) queryResult.get("non_null_count")).longValue();
        Long nullCount = totalCount - nonNullCount;

        result.setTotalCount(totalCount);
        result.setPassCount(nonNullCount);
        result.setFailCount(nullCount);
        result.setPassRate(totalCount > 0 ? (double) nonNullCount / totalCount : 1.0);

        return result;
    }

    /**
     * å‡†ç¡®æ€§æ£€æŸ¥
     */
    private QualityCheckResult checkAccuracy(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());

        // æ ¹æ®è§„åˆ™æ¨¡æ¿ç”Ÿæˆæ£€æŸ¥SQL
        String checkSql = generateAccuracyCheckSQL(rule, table);

        Map<String, Object> queryResult = executeQuery(checkSql);

        Long totalCount = ((Number) queryResult.get("total_count")).longValue();
        Long validCount = ((Number) queryResult.get("valid_count")).longValue();
        Long invalidCount = totalCount - validCount;

        result.setTotalCount(totalCount);
        result.setPassCount(validCount);
        result.setFailCount(invalidCount);
        result.setPassRate(totalCount > 0 ? (double) validCount / totalCount : 1.0);

        return result;
    }

    /**
     * ä¸€è‡´æ€§æ£€æŸ¥
     */
    private QualityCheckResult checkConsistency(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());

        // æ£€æŸ¥è·¨è¡¨ä¸€è‡´æ€§
        String checkSql = generateConsistencyCheckSQL(rule, table);

        Map<String, Object> queryResult = executeQuery(checkSql);

        Long totalCount = ((Number) queryResult.get("total_count")).longValue();
        Long consistentCount = ((Number) queryResult.get("consistent_count")).longValue();
        Long inconsistentCount = totalCount - consistentCount;

        result.setTotalCount(totalCount);
        result.setPassCount(consistentCount);
        result.setFailCount(inconsistentCount);
        result.setPassRate(totalCount > 0 ? (double) consistentCount / totalCount : 1.0);

        return result;
    }

    /**
     * å”¯ä¸€æ€§æ£€æŸ¥
     */
    private QualityCheckResult checkUniqueness(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());

        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count FROM ")
            .append(table.getDatabaseName()).append(".").append(table.getTableName());

        Map<String, Object> totalResult = executeQuery(sql.toString());
        Long totalCount = ((Number) totalResult.get("total_count")).longValue();

        StringBuilder duplicateSql = new StringBuilder();
        duplicateSql.append("SELECT COUNT(*) as duplicate_count FROM (")
            .append("SELECT ").append(rule.getTargetColumn())
            .append(" FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName())
            .append(" GROUP BY ").append(rule.getTargetColumn())
            .append(" HAVING COUNT(*) > 1) t");

        Map<String, Object> duplicateResult = executeQuery(duplicateSql.toString());
        Long duplicateCount = ((Number) duplicateResult.get("duplicate_count")).longValue();

        Long uniqueCount = totalCount - duplicateCount;

        result.setTotalCount(totalCount);
        result.setPassCount(uniqueCount);
        result.setFailCount(duplicateCount);
        result.setPassRate(totalCount > 0 ? (double) uniqueCount / totalCount : 1.0);

        return result;
    }

    /**
     * åŠæ—¶æ€§æ£€æŸ¥
     */
    private QualityCheckResult checkTimeliness(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());

        // ä»è§„åˆ™å‚æ•°ä¸­è·å–æ—¶é—´é˜ˆå€¼
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> params = mapper.readValue(rule.getRuleParams(), Map.class);
        String timeColumn = (String) params.get("timeColumn");
        Long hoursThreshold = ((Number) params.get("hoursThreshold")).longValue();

        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count, ")
            .append("SUM(CASE WHEN TIMESTAMPDIFF(HOUR, ")
            .append(timeColumn).append(", NOW()) <= ").append(hoursThreshold)
            .append(" THEN 1 ELSE 0 END) as timely_count ")
            .append("FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName());

        Map<String, Object> queryResult = executeQuery(sql.toString());

        Long totalCount = ((Number) queryResult.get("total_count")).longValue();
        Long timelyCount = ((Number) queryResult.get("timely_count")).longValue();
        Long untimelyCount = totalCount - timelyCount;

        result.setTotalCount(totalCount);
        result.setPassCount(timelyCount);
        result.setFailCount(untimelyCount);
        result.setPassRate(totalCount > 0 ? (double) timelyCount / totalCount : 1.0);

        return result;
    }

    /**
     * æœ‰æ•ˆæ€§æ£€æŸ¥
     */
    private QualityCheckResult checkValidity(QualityRule rule, QualityCheckResult result) {
        TableMetadata table = tableMetadataMapper.selectById(rule.getTableId());

        // æ ¹æ®è§„åˆ™å‚æ•°ç”ŸæˆéªŒè¯SQL
        String checkSql = generateValidityCheckSQL(rule, table);

        Map<String, Object> queryResult = executeQuery(checkSql);

        Long totalCount = ((Number) queryResult.get("total_count")).longValue();
        Long validCount = ((Number) queryResult.get("valid_count")).longValue();
        Long invalidCount = totalCount - validCount;

        result.setTotalCount(totalCount);
        result.setPassCount(validCount);
        result.setFailCount(invalidCount);
        result.setPassRate(totalCount > 0 ? (double) validCount / totalCount : 1.0);

        return result;
    }

    /**
     * æ‰§è¡ŒSQLæŸ¥è¯¢
     */
    private Map<String, Object> executeQuery(String sql) {
        // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…æ•°æ®æºé…ç½®æ‰§è¡ŒSQL
        // è¿”å›æŸ¥è¯¢ç»“æœ
        // ...
        return new HashMap<>();
    }

    /**
     * ç”Ÿæˆå‡†ç¡®æ€§æ£€æŸ¥SQL
     */
    private String generateAccuracyCheckSQL(QualityRule rule, TableMetadata table) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> params = mapper.readValue(rule.getRuleParams(), Map.class);

        String validationRule = (String) params.get("validationRule");

        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count, ")
            .append("SUM(CASE WHEN ").append(validationRule).append(" THEN 1 ELSE 0 END) as valid_count ")
            .append("FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName());

        return sql.toString();
    }

    /**
     * ç”Ÿæˆä¸€è‡´æ€§æ£€æŸ¥SQL
     */
    private String generateConsistencyCheckSQL(QualityRule rule, TableMetadata table) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> params = mapper.readValue(rule.getRuleParams(), Map.class);

        String referenceTable = (String) params.get("referenceTable");
        String joinCondition = (String) params.get("joinCondition");

        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count, ")
            .append("COUNT(t1.id) as consistent_count ")
            .append("FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName())
            .append(" t1 LEFT JOIN ").append(referenceTable).append(" t2 ON ").append(joinCondition);

        return sql.toString();
    }

    /**
     * ç”Ÿæˆæœ‰æ•ˆæ€§æ£€æŸ¥SQL
     */
    private String generateValidityCheckSQL(QualityRule rule, TableMetadata table) {
        ObjectMapper mapper = new ObjectMapper();
        Map<String, Object> params = mapper.readValue(rule.getRuleParams(), Map.class);

        String validationRule = (String) params.get("validationRule");

        StringBuilder sql = new StringBuilder();
        sql.append("SELECT COUNT(*) as total_count, ")
            .append("SUM(CASE WHEN ").append(validationRule).append(" THEN 1 ELSE 0 END) as valid_count ")
            .append("FROM ").append(table.getDatabaseName()).append(".").append(table.getTableName());

        return sql.toString();
    }
}

/**
 * æ•°æ®è´¨é‡ç›‘æ§Job
 */
@Component
public class QualityMonitoringJob {

    private static final Logger logger = LoggerFactory.getLogger(QualityMonitoringJob.class);

    @Autowired
    private QualityRuleEngine qualityEngine;

    @Autowired
    private QualityRuleMapper ruleMapper;

    /**
     * æ‰§è¡Œæ‰€æœ‰æ´»è·ƒè§„åˆ™
     */
    @XxlJob("executeQualityChecks")
    public void executeQualityChecks() {
        logger.info("å¼€å§‹æ‰§è¡Œæ•°æ®è´¨é‡æ£€æŸ¥ä»»åŠ¡");

        try {
            List<QualityRule> rules = ruleMapper.selectList(
                new QueryWrapper<QualityRule>().eq("status", "ACTIVE"));

            for (QualityRule rule : rules) {
                try {
                    qualityEngine.executeCheck(rule.getId());
                    logger.info("è§„åˆ™æ‰§è¡Œå®Œæˆ: {}", rule.getRuleName());
                } catch (Exception e) {
                    logger.error("è§„åˆ™æ‰§è¡Œå¤±è´¥: {}", rule.getRuleName(), e);
                }
            }

            logger.info("æ•°æ®è´¨é‡æ£€æŸ¥ä»»åŠ¡å®Œæˆ");
        } catch (Exception e) {
            logger.error("æ•°æ®è´¨é‡æ£€æŸ¥ä»»åŠ¡å¤±è´¥", e);
        }
    }
}
```

### 2. è´¨é‡ç›‘æ§çœ‹æ¿

```java
/**
 * æ•°æ®è´¨é‡ç›‘æ§API
 */
@RestController
@RequestMapping("/api/quality")
@Api(tags = "æ•°æ®è´¨é‡")
public class QualityController {

    @Autowired
    private QualityRuleMapper ruleMapper;

    @Autowired
    private QualityCheckResultMapper resultMapper;

    /**
     * è·å–è´¨é‡æ¦‚è§ˆ
     */
    @GetMapping("/overview")
    @ApiOperation("è·å–è´¨é‡æ¦‚è§ˆ")
    public Result<Map<String, Object>> getQualityOverview(
            @RequestParam(defaultValue = "7") Integer days) {

        Map<String, Object> overview = new HashMap<>();

        // è§„åˆ™æ€»æ•°
        Integer totalRules = ruleMapper.selectCount(new QueryWrapper<>());
        overview.put("totalRules", totalRules);

        // æ´»è·ƒè§„åˆ™æ•°
        Integer activeRules = ruleMapper.selectCount(
            new QueryWrapper<QualityRule>().eq("status", "ACTIVE"));
        overview.put("activeRules", activeRules);

        // è´¨é‡åˆ†æ•°
        Double qualityScore = calculateQualityScore(days);
        overview.put("qualityScore", qualityScore);

        // è¶‹åŠ¿æ•°æ®
        List<Map<String, Object>> trendData = getQualityTrend(days);
        overview.put("trendData", trendData);

        // è§„åˆ™ç±»å‹åˆ†å¸ƒ
        Map<String, Long> typeDistribution = ruleMapper.selectMaps(
            new QueryWrapper<QualityRule>()
                .select("rule_type, COUNT(*) as count")
                .groupBy("rule_type"))
            .stream()
            .collect(Collectors.toMap(
                m -> (String) m.get("rule_type"),
                m -> (Long) m.get("count")
            ));
        overview.put("typeDistribution", typeDistribution);

        return Result.success(overview);
    }

    /**
     * è·å–è´¨é‡è¶‹åŠ¿
     */
    @GetMapping("/trend")
    @ApiOperation("è·å–è´¨é‡è¶‹åŠ¿")
    public Result<List<Map<String, Object>>> getQualityTrend(
            @RequestParam(defaultValue = "30") Integer days) {

        List<Map<String, Object>> trendData = new ArrayList<>();

        Date startDate = DateUtil.offsetDay(new Date(), -days);

        for (int i = 0; i < days; i++) {
            Date date = DateUtil.offsetDay(startDate, i);

            QueryWrapper<QualityCheckResult> wrapper = new QueryWrapper<>();
            wrapper.between("execution_time",
                DateUtil.beginOfDay(date),
                DateUtil.endOfDay(date));

            List<QualityCheckResult> results = resultMapper.selectList(wrapper);

            if (!results.isEmpty()) {
                double avgPassRate = results.stream()
                    .mapToDouble(QualityCheckResult::getPassRate)
                    .average()
                    .orElse(0.0);

                Map<String, Object> dayData = new HashMap<>();
                dayData.put("date", DateUtil.formatDate(date));
                dayData.put("passRate", avgPassRate);
                dayData.put("checkCount", results.size());

                trendData.add(dayData);
            }
        }

        return Result.success(trendData);
    }

    /**
     * è·å–è§„åˆ™æ‰§è¡Œå†å²
     */
    @GetMapping("/rules/{ruleId}/history")
    @ApiOperation("è·å–è§„åˆ™æ‰§è¡Œå†å²")
    public Result<Page<QualityCheckResult>> getRuleHistory(
            @PathVariable Long ruleId,
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "20") Integer size) {

        Page<QualityCheckResult> pageInfo = new Page<>(page, size);

        QueryWrapper<QualityCheckResult> wrapper = new QueryWrapper<>();
        wrapper.eq("rule_id", ruleId)
            .orderByDesc("execution_time");

        pageInfo = resultMapper.selectPage(pageInfo, wrapper);

        return Result.success(pageInfo);
    }

    /**
     * è®¡ç®—è´¨é‡åˆ†æ•°
     */
    private Double calculateQualityScore(Integer days) {
        Date startDate = DateUtil.offsetDay(new Date(), -days);

        QueryWrapper<QualityCheckResult> wrapper = new QueryWrapper<>();
        wrapper.between("execution_time", startDate, new Date());

        List<QualityCheckResult> results = resultMapper.selectList(wrapper);

        if (results.isEmpty()) {
            return 100.0;
        }

        // åŠ æƒè®¡ç®—è´¨é‡åˆ†æ•°
        double totalScore = 0;
        double totalWeight = 0;

        for (QualityCheckResult result : results) {
            double score = result.getPassRate() * 100;
            double weight = result.getSeverity().equals("FATAL") ? 5 :
                          result.getSeverity().equals("ERROR") ? 3 :
                          result.getSeverity().equals("WARNING") ? 2 : 1;

            totalScore += score * weight;
            totalWeight += weight;
        }

        return totalWeight > 0 ? totalScore / totalWeight : 100.0;
    }
}
```

---

## ğŸ”— æ•°æ®è¡€ç¼˜ç®¡ç†

### 1. è¡€ç¼˜å…³ç³»æ¨¡å‹

```java
/**
 * æ•°æ®è¡€ç¼˜èŠ‚ç‚¹
 */
@Entity
@Table(name = "dg_lineage_node")
@Data
@EqualsAndHashCode(callSuper = true)
public class LineageNode extends BaseEntity {

    /**
     * èŠ‚ç‚¹ç±»å‹ (TABLE/COLUMN/TRANSFORMATION)
     */
    @Column(name = "node_type", length = 20)
    private String nodeType;

    /**
     * èŠ‚ç‚¹åç§°
     */
    @Column(name = "node_name", length = 200)
    private String nodeName;

    /**
     * èŠ‚ç‚¹æè¿°
     */
    @Column(name = "description", length = 500)
    private String description;

    /**
     * è¡¨ID(å¦‚æœæ˜¯è¡¨èŠ‚ç‚¹)
     */
    @Column(name = "table_id")
    private Long tableId;

    /**
     * å­—æ®µID(å¦‚æœæ˜¯å­—æ®µèŠ‚ç‚¹)
     */
    @Column(name = "column_id")
    private Long columnId;

    /**
     * æ‰€å±æ•°æ®æº
     */
    @Column(name = "datasource_id")
    private Long datasourceId;

    /**
     * èŠ‚ç‚¹å±æ€§(JSON)
     */
    @Column(name = "node_properties", columnDefinition = "TEXT")
    private String nodeProperties;
}

/**
 * æ•°æ®è¡€ç¼˜å…³ç³»
 */
@Entity
@Table(name = "dg_lineage_edge")
@Data
@EqualsAndHashCode(callSuper = true)
public class LineageEdge extends BaseEntity {

    /**
     * æºèŠ‚ç‚¹ID
     */
    @Column(name = "source_node_id")
    private Long sourceNodeId;

    /**
     * ç›®æ ‡èŠ‚ç‚¹ID
     */
    @Column(name = "target_node_id")
    private Long targetNodeId;

    /**
     * å…³ç³»ç±»å‹ (DERIVED_FROM/TRANSFORMS/AGGREGATES/LOOKS_UP)
     */
    @Column(name = "edge_type", length = 50)
    private String edgeType;

    /**
     * è½¬æ¢é€»è¾‘
     */
    @Column(name = "transformation_logic", columnDefinition = "TEXT")
    private String transformationLogic;

    /**
     * æ‰§è¡Œé¡ºåº
     */
    @Column(name = "execution_order")
    private Integer executionOrder;

    /**
     * ä»»åŠ¡ID(ETLä»»åŠ¡)
     */
    @Column(name = "job_id")
    private Long jobId;
}

/**
 * ETLä½œä¸š
 */
@Entity
@Table(name = "dg_etl_job")
@Data
@EqualsAndHashCode(callSuper = true)
public class EtlJob extends BaseEntity {

    /**
     * ä½œä¸šåç§°
     */
    @Column(name = "job_name", length = 100)
    private String jobName;

    /**
     * ä½œä¸šç±»å‹ (BATCH/STREAMING)
     */
    @Column(name = "job_type", length = 20)
    private String jobType;

    /**
     * ä½œä¸šæè¿°
     */
    @Column(name = "description", length = 500)
    private String description;

    /**
     * æºç³»ç»Ÿ
     */
    @Column(name = "source_system", length = 100)
    private String sourceSystem;

    /**
     * ç›®æ ‡ç³»ç»Ÿ
     */
    @Column(name = "target_system", length = 100)
    private String targetSystem;

    /**
     * ä½œä¸šé…ç½®(JSON)
     */
    @Column(name = "job_config", columnDefinition = "TEXT")
    private String jobConfig;

    /**
     * è°ƒåº¦è¡¨è¾¾å¼
     */
    @Column(name = "cron_expression", length = 100)
    private String cronExpression;

    /**
     * çŠ¶æ€
     */
    @Column(name = "status", length = 20)
    private String status;

    /**
     * æœ€åæ‰§è¡Œæ—¶é—´
     */
    @Column(name = "last_execution_time")
    private Date lastExecutionTime;
}

/**
 * æ•°æ®è¡€ç¼˜æœåŠ¡
 */
@Service
public class LineageService {

    private static final Logger logger = LoggerFactory.getLogger(LineageService.class);

    @Autowired
    private LineageNodeMapper nodeMapper;

    @Autowired
    private LineageEdgeMapper edgeMapper;

    @Autowired
    private EtlJobMapper jobMapper;

    @Autowired
    private TableMetadataMapper tableMetadataMapper;

    /**
     * æ„å»ºæ•°æ®è¡€ç¼˜å…³ç³»
     */
    @Transactional
    public void buildLineage(Long tableId, String etlJobName) {
        TableMetadata table = tableMetadataMapper.selectById(tableId);
        if (table == null) {
            throw new BusinessException("è¡¨ä¸å­˜åœ¨");
        }

        // è·å–ETLä½œä¸š
        EtlJob job = jobMapper.selectOne(
            new QueryWrapper<EtlJob>().eq("job_name", etlJobName));

        // æ„å»ºè¡€ç¼˜èŠ‚ç‚¹
        LineageNode targetNode = createTableNode(table);

        // ä»ä½œä¸šé…ç½®ä¸­è§£ææºè¡¨
        List<TableMetadata> sourceTables = parseSourceTables(job);

        for (TableMetadata sourceTable : sourceTables) {
            LineageNode sourceNode = createTableNode(sourceTable);

            // åˆ›å»ºè¡€ç¼˜è¾¹
            LineageEdge edge = new LineageEdge();
            edge.setSourceNodeId(sourceNode.getId());
            edge.setTargetNodeId(targetNode.getId());
            edge.setEdgeType("DERIVED_FROM");
            edge.setJobId(job.getId());
            edge.setExecutionOrder(1);

            edgeMapper.insert(edge);
        }
    }

    /**
     * è·å–å®Œæ•´è¡€ç¼˜é“¾è·¯
     */
    public Map<String, Object> getLineageGraph(Long tableId) {
        TableMetadata table = tableMetadataMapper.selectById(tableId);

        Map<String, Object> result = new HashMap<>();

        // è·å–ä¸Šæ¸¸è¡€ç¼˜
        List<Map<String, Object>> upstream = getUpstreamLineage(tableId);

        // è·å–ä¸‹æ¸¸è¡€ç¼˜
        List<Map<String, Object>> downstream = getDownstreamLineage(tableId);

        result.put("table", table);
        result.put("upstream", upstream);
        result.put("downstream", downstream);

        return result;
    }

    /**
     * è·å–ä¸Šæ¸¸è¡€ç¼˜
     */
    public List<Map<String, Object>> getUpstreamLineage(Long tableId) {
        List<Map<String, Object>> upstream = new ArrayList<>();

        // é€’å½’è·å–ä¸Šæ¸¸è¡€ç¼˜
        collectUpstream(tableId, 0, upstream);

        return upstream;
    }

    /**
     * è·å–ä¸‹æ¸¸è¡€ç¼˜
     */
    public List<Map<String, Object>> getDownstreamLineage(Long tableId) {
        List<Map<String, Object>> downstream = new ArrayList<>();

        // é€’å½’è·å–ä¸‹æ¸¸è¡€ç¼˜
        collectDownstream(tableId, 0, downstream);

        return downstream;
    }

    /**
     * é€’å½’æ”¶é›†ä¸Šæ¸¸è¡€ç¼˜
     */
    private void collectUpstream(Long tableId, int depth, List<Map<String, Object>> result) {
        if (depth > 5) { // é˜²æ­¢å¾ªç¯å¼•ç”¨ï¼Œé™åˆ¶æ·±åº¦
            return;
        }

        QueryWrapper<LineageEdge> wrapper = new QueryWrapper<>();
        wrapper.eq("target_node_id", getTableNodeId(tableId));

        List<LineageEdge> edges = edgeMapper.selectList(wrapper);

        for (LineageEdge edge : edges) {
            LineageNode sourceNode = nodeMapper.selectById(edge.getSourceNodeId());

            Map<String, Object> nodeInfo = new HashMap<>();
            nodeInfo.put("node", sourceNode);
            nodeInfo.put("depth", depth);
            nodeInfo.put("edgeType", edge.getEdgeType());
            nodeInfo.put("transformation", edge.getTransformationLogic());

            result.add(nodeInfo);

            // é€’å½’æ”¶é›†ä¸Šæ¸¸
            if (sourceNode.getTableId() != null) {
                collectUpstream(sourceNode.getTableId(), depth + 1, result);
            }
        }
    }

    /**
     * é€’å½’æ”¶é›†ä¸‹æ¸¸è¡€ç¼˜
     */
    private void collectDownstream(Long tableId, int depth, List<Map<String, Object>> result) {
        if (depth > 5) { // é˜²æ­¢å¾ªç¯å¼•ç”¨ï¼Œé™åˆ¶æ·±åº¦
            return;
        }

        QueryWrapper<LineageEdge> wrapper = new QueryWrapper<>();
        wrapper.eq("source_node_id", getTableNodeId(tableId));

        List<LineageEdge> edges = edgeMapper.selectList(wrapper);

        for (LineageEdge edge : edges) {
            LineageNode targetNode = nodeMapper.selectById(edge.getTargetNodeId());

            Map<String, Object> nodeInfo = new HashMap<>();
            nodeInfo.put("node", targetNode);
            nodeInfo.put("depth", depth);
            nodeInfo.put("edgeType", edge.getEdgeType());
            nodeInfo.put("transformation", edge.getTransformationLogic());

            result.add(nodeInfo);

            // é€’å½’æ”¶é›†ä¸‹æ¸¸
            if (targetNode.getTableId() != null) {
                collectDownstream(targetNode.getTableId(), depth + 1, result);
            }
        }
    }

    /**
     * å½±å“åˆ†æ
     */
    public List<Map<String, Object>> impactAnalysis(Long tableId) {
        List<Map<String, Object>> impactedObjects = new ArrayList<>();

        // è·å–ä¸‹æ¸¸å½±å“
        List<Map<String, Object>> downstream = getDownstreamLineage(tableId);

        for (Map<String, Object> downstreamItem : downstream) {
            LineageNode node = (LineageNode) downstreamItem.get("node");

            Map<String, Object> impact = new HashMap<>();
            impact.put("type", "DOWNSTREAM");
            impact.put("object", node);
            impact.put("description", "è¡¨ " + node.getNodeName() + " å—å½“å‰è¡¨å˜æ›´å½±å“");

            impactedObjects.add(impact);
        }

        return impactedObjects;
    }

    /**
     * åˆ›å»ºè¡¨èŠ‚ç‚¹
     */
    private LineageNode createTableNode(TableMetadata table) {
        QueryWrapper<LineageNode> wrapper = new QueryWrapper<>();
        wrapper.eq("node_type", "TABLE")
            .eq("table_id", table.getId());

        LineageNode existingNode = nodeMapper.selectOne(wrapper);

        if (existingNode != null) {
            return existingNode;
        }

        LineageNode node = new LineageNode();
        node.setNodeType("TABLE");
        node.setNodeName(table.getDatabaseName() + "." + table.getTableName());
        node.setTableId(table.getId());
        node.setDatasourceId(table.getDatasourceId());

        nodeMapper.insert(node);
        return node;
    }

    /**
     * è·å–è¡¨çš„èŠ‚ç‚¹ID
     */
    private Long getTableNodeId(Long tableId) {
        QueryWrapper<LineageNode> wrapper = new QueryWrapper<>();
        wrapper.eq("node_type", "TABLE")
            .eq("table_id", tableId);

        LineageNode node = nodeMapper.selectOne(wrapper);
        return node != null ? node.getId() : null;
    }

    /**
     * è§£ææºè¡¨
     */
    private List<TableMetadata> parseSourceTables(EtlJob job) {
        // ä»ä½œä¸šé…ç½®ä¸­è§£ææºè¡¨
        // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…çš„ä½œä¸šé…ç½®æ ¼å¼è¿›è¡Œè§£æ
        // ç¤ºä¾‹æ ¼å¼ï¼š{"sourceTables": ["db1.table1", "db1.table2"]}

        List<TableMetadata> sourceTables = new ArrayList<>();

        try {
            ObjectMapper mapper = new ObjectMapper();
            Map<String, Object> config = mapper.readValue(job.getJobConfig(), Map.class);

            List<String> sourceTableNames = (List<String>) config.get("sourceTables");

            for (String tableName : sourceTableNames) {
                String[] parts = tableName.split("\\.");
                if (parts.length == 2) {
                    TableMetadata table = tableMetadataMapper.findByName(parts[0], parts[1]);
                    if (table != null) {
                        sourceTables.add(table);
                    }
                }
            }
        } catch (Exception e) {
            logger.error("è§£ææºè¡¨å¤±è´¥", e);
        }

        return sourceTables;
    }
}

/**
 * æ•°æ®è¡€ç¼˜API
 */
@RestController
@RequestMapping("/api/lineage")
@Api(tags = "æ•°æ®è¡€ç¼˜")
public class LineageController {

    @Autowired
    private LineageService lineageService;

    /**
     * è·å–è¡€ç¼˜å…³ç³»å›¾
     */
    @GetMapping("/graph/{tableId}")
    @ApiOperation("è·å–è¡€ç¼˜å…³ç³»å›¾")
    public Result<Map<String, Object>> getLineageGraph(@PathVariable Long tableId) {
        Map<String, Object> graph = lineageService.getLineageGraph(tableId);
        return Result.success(graph);
    }

    /**
     * è·å–ä¸Šæ¸¸è¡€ç¼˜
     */
    @GetMapping("/upstream/{tableId}")
    @ApiOperation("è·å–ä¸Šæ¸¸è¡€ç¼˜")
    public Result<List<Map<String, Object>>> getUpstream(@PathVariable Long tableId) {
        List<Map<String, Object>> upstream = lineageService.getUpstreamLineage(tableId);
        return Result.success(upstream);
    }

    /**
     * è·å–ä¸‹æ¸¸è¡€ç¼˜
     */
    @GetMapping("/downstream/{tableId}")
    @ApiOperation("è·å–ä¸‹æ¸¸è¡€ç¼˜")
    public Result<List<Map<String, Object>>> getDownstream(@PathVariable Long tableId) {
        List<Map<String, Object>> downstream = lineageService.getDownstreamLineage(tableId);
        return Result.success(downstream);
    }

    /**
     * å½±å“åˆ†æ
     */
    @GetMapping("/impact/{tableId}")
    @ApiOperation("å½±å“åˆ†æ")
    public Result<List<Map<String, Object>>> impactAnalysis(@PathVariable Long tableId) {
        List<Map<String, Object>> impacted = lineageService.impactAnalysis(tableId);
        return Result.success(impacted);
    }

    /**
     * æ„å»ºè¡€ç¼˜å…³ç³»
     */
    @PostMapping("/build")
    @ApiOperation("æ„å»ºè¡€ç¼˜å…³ç³»")
    public Result<Void> buildLineage(@RequestParam Long tableId,
                                     @RequestParam String etlJobName) {
        lineageService.buildLineage(tableId, etlJobName);
        return Result.success();
    }
}
```

---

## ğŸ”’ æ•°æ®å®‰å…¨ä¸åˆè§„

### 1. æ•æ„Ÿæ•°æ®å‘ç°

```java
/**
 * æ•æ„Ÿæ•°æ®è§„åˆ™
 */
@Entity
@Table(name = "dg_sensitive_rule")
@Data
@EqualsAndHashCode(callSuper = true)
public class SensitiveRule extends BaseEntity {

    /**
     * è§„åˆ™åç§°
     */
    @Column(name = "rule_name", length = 100)
    private String ruleName;

    /**
     * è§„åˆ™ç±»å‹ (PATTERN_REGEX/DICTIONARY/ML_BASED)
     */
    @Column(name = "rule_type", length = 50)
    private String ruleType;

    /**
     * æ•°æ®åˆ†ç±» (PII/PCI/PHI/FINANCIAL/SECRET)
     */
    @Column(name = "data_category", length = 50)
    private String dataCategory;

    /**
     * æ£€æµ‹è§„åˆ™
     */
    @Column(name = "detection_rule", columnDefinition = "TEXT")
    private String detectionRule;

    /**
     * ä¸¥é‡ç¨‹åº¦
     */
    @Column(name = "severity", length = 20)
    private String severity;

    /**
     * çŠ¶æ€
     */
    @Column(name = "status", length = 20)
    private String status;
}

/**
 * æ•æ„Ÿæ•°æ®æ‰«æç»“æœ
 */
@Entity
@Table(name = "dg_sensitive_scan_result")
@Data
@EqualsAndHashCode(callSuper = true)
public class SensitiveScanResult extends BaseEntity {

    /**
     * è¡¨ID
     */
    @Column(name = "table_id")
    private Long tableId;

    /**
     * å­—æ®µID
     */
    @Column(name = "column_id")
    private Long columnId;

    /**
     * æ•æ„Ÿç±»å‹
     */
    @Column(name = "sensitive_type", length = 100)
    private String sensitiveType;

    /**
     * ç½®ä¿¡åº¦
     */
    @Column(name = "confidence")
    private Double confidence;

    /**
     * æ•æ„Ÿæ•°æ®æ•°é‡
     */
    @Column(name = "sensitive_count")
    private Long sensitiveCount;

    /**
     * æ€»æ•°é‡
     */
    @Column(name = "total_count")
    private Long totalCount;

    /**
     * æ•æ„Ÿæ¯”ä¾‹
     */
    @Column(name = "sensitive_rate")
    private Double sensitiveRate;

    /**
     * æ‰«ææ—¶é—´
     */
    @Column(name = "scan_time")
    private Date scanTime;
}

/**
 * æ•æ„Ÿæ•°æ®å‘ç°æœåŠ¡
 */
@Service
public class SensitiveDataDiscoveryService {

    private static final Logger logger = LoggerFactory.getLogger(SensitiveDataDiscoveryService.class);

    @Autowired
    private SensitiveRuleMapper ruleMapper;

    @Autowired
    private SensitiveScanResultMapper resultMapper;

    @Autowired
    private TableMetadataMapper tableMetadataMapper;

    @Autowired
    private ColumnMetadataMapper columnMetadataMapper;

    /**
     * æ‰«æè¡¨ä¸­çš„æ•æ„Ÿæ•°æ®
     */
    @Transactional
    public void scanSensitiveData(Long tableId) {
        TableMetadata table = tableMetadataMapper.selectById(tableId);
        if (table == null) {
            throw new BusinessException("è¡¨ä¸å­˜åœ¨");
        }

        logger.info("å¼€å§‹æ‰«ææ•æ„Ÿæ•°æ®: {}", table.getTableName());

        // è·å–æ‰€æœ‰è§„åˆ™
        List<SensitiveRule> rules = ruleMapper.selectList(
            new QueryWrapper<SensitiveRule>().eq("status", "ACTIVE"));

        // è·å–æ‰€æœ‰å­—æ®µ
        List<ColumnMetadata> columns = columnMetadataMapper.selectList(
            new QueryWrapper<ColumnMetadata>().eq("table_id", tableId));

        for (ColumnMetadata column : columns) {
            for (SensitiveRule rule : rules) {
                try {
                    scanColumn(table, column, rule);
                } catch (Exception e) {
                    logger.error("å­—æ®µæ‰«æå¤±è´¥: {}.{}",
                        table.getTableName(), column.getColumnName(), e);
                }
            }
        }

        logger.info("æ•æ„Ÿæ•°æ®æ‰«æå®Œæˆ: {}", table.getTableName());
    }

    /**
     * æ‰«æå•ä¸ªå­—æ®µ
     */
    private void scanColumn(TableMetadata table, ColumnMetadata column, SensitiveRule rule) {
        try {
            String detectionResult = executeDetection(table, column, rule);

            if (detectionResult != null && !detectionResult.isEmpty()) {
                SensitiveScanResult result = new SensitiveScanResult();
                result.setTableId(table.getId());
                result.setColumnId(column.getId());
                result.setSensitiveType(rule.getDataCategory());
                result.setConfidence(0.8); // é»˜è®¤ç½®ä¿¡åº¦
                result.setScanTime(new Date());

                // è®¡ç®—æ•æ„Ÿæ•°æ®æ¯”ä¾‹
                Map<String, Object> stats = calculateSensitiveStats(table, column, rule);
                result.setTotalCount((Long) stats.get("totalCount"));
                result.setSensitiveCount((Long) stats.get("sensitiveCount"));
                result.setSensitiveRate((Double) stats.get("sensitiveRate"));

                resultMapper.insert(result);
            }
        } catch (Exception e) {
            logger.error("å­—æ®µæ£€æµ‹å¤±è´¥", e);
        }
    }

    /**
     * æ‰§è¡Œæ•æ„Ÿæ•°æ®æ£€æµ‹
     */
    private String executeDetection(TableMetadata table, ColumnMetadata column, SensitiveRule rule) {
        StringBuilder sql = new StringBuilder();

        switch (rule.getRuleType()) {
            case "PATTERN_REGEX":
                sql.append("SELECT COUNT(*) FROM ")
                    .append(table.getDatabaseName()).append(".").append(table.getTableName())
                    .append(" WHERE ").append(column.getColumnName())
                    .append(" REGEXP '").append(rule.getDetectionRule()).append("'");
                break;

            case "DICTIONARY":
                sql.append("SELECT COUNT(*) FROM ")
                    .append(table.getDatabaseName()).append(".").append(table.getTableName())
                    .append(" WHERE ").append(column.getColumnName())
                    .append(" IN (").append(rule.getDetectionRule()).append(")");
                break;

            default:
                logger.warn("ä¸æ”¯æŒçš„æ£€æµ‹è§„åˆ™ç±»å‹: {}", rule.getRuleType());
                return null;
        }

        // æ‰§è¡ŒSQLæŸ¥è¯¢
        try {
            Long count = executeCountQuery(sql.toString());
            return count > 0 ? "FOUND" : null;
        } catch (Exception e) {
            logger.error("æ‰§è¡Œæ£€æµ‹æŸ¥è¯¢å¤±è´¥", e);
            return null;
        }
    }

    /**
     * è®¡ç®—æ•æ„Ÿæ•°æ®ç»Ÿè®¡
     */
    private Map<String, Object> calculateSensitiveStats(TableMetadata table,
                                                       ColumnMetadata column,
                                                       SensitiveRule rule) {
        Map<String, Object> stats = new HashMap<>();

        String totalSql = "SELECT COUNT(*) FROM " +
            table.getDatabaseName() + "." + table.getTableName();

        String sensitiveSql = "SELECT COUNT(*) FROM " +
            table.getDatabaseName() + "." + table.getTableName() +
            " WHERE " + column.getColumnName() + " " + getWhereClause(rule);

        try {
            Long totalCount = executeCountQuery(totalSql);
            Long sensitiveCount = executeCountQuery(sensitiveSql);

            stats.put("totalCount", totalCount);
            stats.put("sensitiveCount", sensitiveCount);
            stats.put("sensitiveRate", totalCount > 0 ?
                (double) sensitiveCount / totalCount : 0.0);

        } catch (Exception e) {
            logger.error("è®¡ç®—ç»Ÿè®¡ä¿¡æ¯å¤±è´¥", e);
            stats.put("totalCount", 0L);
            stats.put("sensitiveCount", 0L);
            stats.put("sensitiveRate", 0.0);
        }

        return stats;
    }

    /**
     * è·å–WHEREå­å¥
     */
    private String getWhereClause(SensitiveRule rule) {
        switch (rule.getRuleType()) {
            case "PATTERN_REGEX":
                return "REGEXP '" + rule.getDetectionRule() + "'";
            case "DICTIONARY":
                return "IN (" + rule.getDetectionRule() + ")";
            default:
                return "IS NOT NULL";
        }
    }

    /**
     * æ‰§è¡Œè®¡æ•°æŸ¥è¯¢
     */
    private Long executeCountQuery(String sql) {
        // è¿™é‡Œéœ€è¦æ ¹æ®å®é™…æ•°æ®æºæ‰§è¡ŒæŸ¥è¯¢
        // è¿”å›æŸ¥è¯¢ç»“æœ
        return 0L;
    }
}

/**
 * æ•°æ®è„±æ•æœåŠ¡
 */
@Service
public class DataMaskingService {

    /**
     * æ‰‹æœºå·è„±æ•
     */
    public String maskPhoneNumber(String phoneNumber) {
        if (StringUtils.isEmpty(phoneNumber) || phoneNumber.length() != 11) {
            return phoneNumber;
        }
        return phoneNumber.substring(0, 3) + "****" + phoneNumber.substring(7);
    }

    /**
     * èº«ä»½è¯å·è„±æ•
     */
    public String maskIdCard(String idCard) {
        if (StringUtils.isEmpty(idCard) || idCard.length() < 8) {
            return idCard;
        }
        return idCard.substring(0, 6) + "********" + idCard.substring(14);
    }

    /**
     * é‚®ç®±è„±æ•
     */
    public String maskEmail(String email) {
        if (StringUtils.isEmpty(email) || !email.contains("@")) {
            return email;
        }

        int atIndex = email.indexOf("@");
        String username = email.substring(0, atIndex);
        String domain = email.substring(atIndex);

        if (username.length() <= 2) {
            return "*" + domain;
        }

        return username.substring(0, 2) + "***" + domain;
    }

    /**
     * é“¶è¡Œå¡å·è„±æ•
     */
    public String maskBankCard(String bankCard) {
        if (StringUtils.isEmpty(bankCard) || bankCard.length() < 8) {
            return bankCard;
        }

        return "**** **** **** " + bankCard.substring(bankCard.length() - 4);
    }

    /**
     * å§“åè„±æ•
     */
    public String maskName(String name) {
        if (StringUtils.isEmpty(name)) {
            return name;
        }

        if (name.length() == 1) {
            return name;
        }

        return name.substring(0, 1) + "*".repeat(name.length() - 1);
    }

    /**
     * åœ°å€è„±æ•
     */
    public String maskAddress(String address) {
        if (StringUtils.isEmpty(address)) {
            return address;
        }

        int length = address.length();
        if (length <= 6) {
            return address.substring(0, length / 2) + "*".repeat(length / 2);
        }

        return address.substring(0, 3) + "*".repeat(length - 6) + address.substring(length - 3);
    }

    /**
     * è‡ªå®šä¹‰è„±æ•
     */
    public String maskCustom(String value, int keepStart, int keepEnd, char maskChar) {
        if (StringUtils.isEmpty(value)) {
            return value;
        }

        int length = value.length();
        if (keepStart + keepEnd >= length) {
            return maskChar + "*".repeat(length - 1);
        }

        StringBuilder masked = new StringBuilder();
        masked.append(value.substring(0, keepStart));
        masked.append(maskChar, 0, length - keepStart - keepEnd);
        masked.append(value.substring(length - keepEnd));

        return masked.toString();
    }
}

/**
 * æ•°æ®å®‰å…¨API
 */
@RestController
@RequestMapping("/api/security")
@Api(tags = "æ•°æ®å®‰å…¨")
public class DataSecurityController {

    @Autowired
    private SensitiveDataDiscoveryService discoveryService;

    @Autowired
    private DataMaskingService maskingService;

    /**
     * æ‰«ææ•æ„Ÿæ•°æ®
     */
    @PostMapping("/scan/{tableId}")
    @ApiOperation("æ‰«ææ•æ„Ÿæ•°æ®")
    public Result<Void> scanSensitiveData(@PathVariable Long tableId) {
        discoveryService.scanSensitiveData(tableId);
        return Result.success();
    }

    /**
     * è·å–æ•æ„Ÿæ•°æ®æ¦‚è§ˆ
     */
    @GetMapping("/overview")
    @ApiOperation("è·å–æ•æ„Ÿæ•°æ®æ¦‚è§ˆ")
    public Result<Map<String, Object>> getSensitiveOverview() {
        Map<String, Object> overview = new HashMap<>();

        // TODO: ä»æ•°æ®åº“æŸ¥è¯¢æ•æ„Ÿæ•°æ®ç»Ÿè®¡ä¿¡æ¯

        overview.put("totalSensitiveTables", 0);
        overview.put("totalSensitiveColumns", 0);
        overview.put("highRiskDataCount", 0);
        overview.put("mediumRiskDataCount", 0);
        overview.put("lowRiskDataCount", 0);

        return Result.success(overview);
    }

    /**
     * æ•°æ®è„±æ•
     */
    @PostMapping("/mask")
    @ApiOperation("æ•°æ®è„±æ•")
    public Result<Map<String, String>> maskData(@RequestBody Map<String, String> data) {
        Map<String, String> maskedData = new HashMap<>();

        for (Map.Entry<String, String> entry : data.entrySet()) {
            String key = entry.getKey();
            String value = entry.getValue();

            // æ ¹æ®å­—æ®µç±»å‹åº”ç”¨ä¸åŒçš„è„±æ•ç­–ç•¥
            String maskedValue = maskByFieldType(key, value);
            maskedData.put(key, maskedValue);
        }

        return Result.success(maskedData);
    }

    /**
     * æ ¹æ®å­—æ®µç±»å‹è„±æ•
     */
    private String maskByFieldType(String fieldName, String value) {
        String lowerFieldName = fieldName.toLowerCase();

        if (lowerFieldName.contains("phone") || lowerFieldName.contains("mobile")) {
            return maskingService.maskPhoneNumber(value);
        } else if (lowerFieldName.contains("idcard") || lowerFieldName.contains("id_card")) {
            return maskingService.maskIdCard(value);
        } else if (lowerFieldName.contains("email")) {
            return maskingService.maskEmail(value);
        } else if (lowerFieldName.contains("bank") || lowerFieldName.contains("card")) {
            return maskingService.maskBankCard(value);
        } else if (lowerFieldName.contains("name")) {
            return maskingService.maskName(value);
        } else if (lowerFieldName.contains("address")) {
            return maskingService.maskAddress(value);
        } else {
            // é»˜è®¤ä¿ç•™å‰2ä½å’Œå2ä½
            return maskingService.maskCustom(value, 2, 2, '*');
        }
    }
}
```

---

## ğŸ“Š æ•°æ®æ²»ç†Dashboard

### 1. ç®¡ç†ç•Œé¢

```vue
<template>
  <div class="data-governance-dashboard">
    <el-row :gutter="20">
      <!-- æ•°æ®æ¦‚è§ˆå¡ç‰‡ -->
      <el-col :span="6">
        <el-card class="dashboard-card">
          <div class="card-content">
            <i class="icon-database"></i>
            <div class="card-info">
              <h3>{{ overview.totalTables }}</h3>
              <p>æ•°æ®è¡¨æ€»æ•°</p>
            </div>
          </div>
        </el-card>
      </el-col>

      <el-col :span="6">
        <el-card class="dashboard-card">
          <div class="card-content">
            <i class="icon-quality"></i>
            <div class="card-info">
              <h3>{{ overview.qualityScore }}%</h3>
              <p>æ•°æ®è´¨é‡åˆ†æ•°</p>
            </div>
          </div>
        </el-card>
      </el-col>

      <el-col :span="6">
        <el-card class="dashboard-card">
          <div class="card-content">
            <i class="icon-lineage"></i>
            <div class="card-info">
              <h3>{{ overview.totalLineages }}</h3>
              <p>è¡€ç¼˜å…³ç³»æ•°</p>
            </div>
          </div>
        </el-card>
      </el-col>

      <el-col :span="6">
        <el-card class="dashboard-card">
          <div class="card-content">
            <i class="icon-security"></i>
            <div class="card-info">
              <h3>{{ overview.sensitiveCount }}</h3>
              <p>æ•æ„Ÿæ•°æ®å‘ç°</p>
            </div>
          </div>
        </el-card>
      </el-col>
    </el-row>

    <!-- è´¨é‡è¶‹åŠ¿å›¾è¡¨ -->
    <el-row :gutter="20" style="margin-top: 20px;">
      <el-col :span="12">
        <el-card>
          <h3>æ•°æ®è´¨é‡è¶‹åŠ¿</h3>
          <div id="qualityChart" style="height: 300px;"></div>
        </el-card>
      </el-col>

      <el-col :span="12">
        <el-card>
          <h3>æ•°æ®åˆ†ç±»åˆ†å¸ƒ</h3>
          <div id="classificationChart" style="height: 300px;"></div>
        </el-card>
      </el-col>
    </el-row>

    <!-- æ•°æ®è¡¨åˆ—è¡¨ -->
    <el-row style="margin-top: 20px;">
      <el-col :span="24">
        <el-card>
          <div slot="header">
            <span>æ•°æ®è¡¨æ¦‚è§ˆ</span>
            <el-button type="primary" size="small" @click="refreshData">
              åˆ·æ–°æ•°æ®
            </el-button>
          </div>

          <el-table :data="tableList" stripe style="width: 100%">
            <el-table-column prop="tableName" label="è¡¨å"></el-table-column>
            <el-table-column prop="databaseName" label="æ•°æ®åº“"></el-table-column>
            <el-table-column prop="rowCount" label="æ•°æ®é‡"></el-table-column>
            <el-table-column prop="dataClassification" label="æ•°æ®åˆ†çº§"></el-table-column>
            <el-table-column label="è´¨é‡åˆ†æ•°">
              <template slot-scope="scope">
                <el-tag :type="getQualityTagType(scope.row.qualityScore)">
                  {{ scope.row.qualityScore }}%
                </el-tag>
              </template>
            </el-table-column>
            <el-table-column label="æ“ä½œ">
              <template slot-scope="scope">
                <el-button type="text" @click="viewLineage(scope.row.id)">
                  æŸ¥çœ‹è¡€ç¼˜
                </el-button>
                <el-button type="text" @click="viewQuality(scope.row.id)">
                  è´¨é‡æŠ¥å‘Š
                </el-button>
              </template>
            </el-table-column>
          </el-table>

          <el-pagination
            @size-change="handleSizeChange"
            @current-change="handleCurrentChange"
            :current-page="currentPage"
            :page-sizes="[10, 20, 50, 100]"
            :page-size="pageSize"
            layout="total, sizes, prev, pager, next, jumper"
            :total="total">
          </el-pagination>
        </el-card>
      </el-col>
    </el-row>

    <!-- è¡€ç¼˜å…³ç³»å¼¹çª— -->
    <el-dialog :visible.sync="lineageDialogVisible" title="æ•°æ®è¡€ç¼˜å…³ç³»" width="80%">
      <div id="lineageGraph" style="height: 500px;"></div>
    </el-dialog>

    <!-- è´¨é‡æŠ¥å‘Šå¼¹çª— -->
    <el-dialog :visible.sync="qualityDialogVisible" title="æ•°æ®è´¨é‡æŠ¥å‘Š" width="60%">
      <div v-if="qualityReport">
        <el-descriptions title="åŸºæœ¬ä¿¡æ¯" :column="2" border>
          <el-descriptions-item label="è¡¨å">{{ qualityReport.tableName }}</el-descriptions-item>
          <el-descriptions-item label="æ•°æ®åº“">{{ qualityReport.databaseName }}</el-descriptions-item>
          <el-descriptions-item label="æ€»æ•°æ®é‡">{{ qualityReport.totalRows }}</el-descriptions-item>
          <el-descriptions-item label="è´¨é‡åˆ†æ•°">{{ qualityReport.qualityScore }}%</el-descriptions-item>
        </el-descriptions>

        <h4 style="margin-top: 20px;">è´¨é‡è§„åˆ™æ£€æŸ¥ç»“æœ</h4>
        <el-table :data="qualityReport.ruleResults" stripe>
          <el-table-column prop="ruleName" label="è§„åˆ™åç§°"></el-table-column>
          <el-table-column prop="ruleType" label="è§„åˆ™ç±»å‹"></el-table-column>
          <el-table-column prop="passRate" label="é€šè¿‡ç‡">
            <template slot-scope="scope">
              {{ (scope.row.passRate * 100).toFixed(2) }}%
            </template>
          </el-table-column>
          <el-table-column prop="status" label="çŠ¶æ€">
            <template slot-scope="scope">
              <el-tag :type="scope.row.status === 'SUCCESS' ? 'success' : 'danger'">
                {{ scope.row.status }}
              </el-tag>
            </template>
          </el-table-column>
        </el-table>
      </div>
    </el-dialog>
  </div>
</template>

<script>
export default {
  name: 'DataGovernanceDashboard',

  data() {
    return {
      overview: {
        totalTables: 0,
        qualityScore: 0,
        totalLineages: 0,
        sensitiveCount: 0
      },
      tableList: [],
      currentPage: 1,
      pageSize: 10,
      total: 0,
      lineageDialogVisible: false,
      qualityDialogVisible: false,
      qualityReport: null,
      qualityChart: null,
      classificationChart: null,
      lineageGraph: null
    }
  },

  mounted() {
    this.loadOverview();
    this.loadTableList();
    this.initCharts();
  },

  methods: {
    // åŠ è½½æ¦‚è§ˆæ•°æ®
    async loadOverview() {
      try {
        const response = await this.$http.get('/api/metadata/overview');
        this.overview = response.data;
      } catch (error) {
        console.error('åŠ è½½æ¦‚è§ˆæ•°æ®å¤±è´¥', error);
      }
    },

    // åŠ è½½è¡¨åˆ—è¡¨
    async loadTableList() {
      try {
        const params = {
          page: this.currentPage,
          size: this.pageSize
        };
        const response = await this.$http.get('/api/metadata/tables', { params });
        this.tableList = response.data.records;
        this.total = response.data.total;
      } catch (error) {
        console.error('åŠ è½½è¡¨åˆ—è¡¨å¤±è´¥', error);
      }
    },

    // åˆå§‹åŒ–å›¾è¡¨
    initCharts() {
      // è´¨é‡è¶‹åŠ¿å›¾è¡¨
      this.qualityChart = echarts.init(document.getElementById('qualityChart'));

      // æ•°æ®åˆ†ç±»åˆ†å¸ƒå›¾è¡¨
      this.classificationChart = echarts.init(document.getElementById('classificationChart'));

      this.loadQualityTrend();
      this.loadClassificationData();
    },

    // åŠ è½½è´¨é‡è¶‹åŠ¿æ•°æ®
    async loadQualityTrend() {
      try {
        const response = await this.$http.get('/api/quality/trend', {
          params: { days: 30 }
        });

        const option = {
          tooltip: {
            trigger: 'axis'
          },
          xAxis: {
            type: 'category',
            data: response.data.map(item => item.date)
          },
          yAxis: {
            type: 'value',
            min: 0,
            max: 100
          },
          series: [{
            name: 'è´¨é‡åˆ†æ•°',
            type: 'line',
            data: response.data.map(item => (item.passRate * 100).toFixed(2)),
            smooth: true,
            lineStyle: {
              color: '#409EFF'
            }
          }]
        };

        this.qualityChart.setOption(option);
      } catch (error) {
        console.error('åŠ è½½è´¨é‡è¶‹åŠ¿æ•°æ®å¤±è´¥', error);
      }
    },

    // åŠ è½½åˆ†ç±»æ•°æ®
    async loadClassificationData() {
      try {
        const response = await this.$http.get('/api/metadata/overview');
        const classificationData = response.data.classificationStats;

        const option = {
          tooltip: {
            trigger: 'item'
          },
          legend: {
            orient: 'vertical',
            left: 'left'
          },
          series: [{
            name: 'æ•°æ®åˆ†ç±»',
            type: 'pie',
            radius: '50%',
            data: Object.entries(classificationData).map(([key, value]) => ({
              name: key,
              value: value
            })),
            emphasis: {
              itemStyle: {
                shadowBlur: 10,
                shadowOffsetX: 0,
                shadowColor: 'rgba(0, 0, 0, 0.5)'
              }
            }
          }]
        };

        this.classificationChart.setOption(option);
      } catch (error) {
        console.error('åŠ è½½åˆ†ç±»æ•°æ®å¤±è´¥', error);
      }
    },

    // æŸ¥çœ‹è¡€ç¼˜å…³ç³»
    async viewLineage(tableId) {
      this.lineageDialogVisible = true;

      // å»¶è¿Ÿåˆå§‹åŒ–å›¾è¡¨
      this.$nextTick(() => {
        this.initLineageGraph(tableId);
      });
    },

    // åˆå§‹åŒ–è¡€ç¼˜å›¾è¡¨
    async initLineageGraph(tableId) {
      try {
        const response = await this.$http.get(`/api/lineage/graph/${tableId}`);

        this.lineageGraph = echarts.init(document.getElementById('lineageGraph'));

        // å¤„ç†è¡€ç¼˜æ•°æ®
        const graphData = this.processLineageData(response.data);

        const option = {
          tooltip: {},
          series: [{
            type: 'graph',
            layout: 'force',
            symbolSize: 50,
            roam: true,
            label: {
              show: true
            },
            edgeSymbol: ['none', 'arrow'],
            edgeSymbolSize: [4, 10],
            data: graphData.nodes,
            links: graphData.links,
            lineStyle: {
              opacity: 0.9,
              width: 2,
              curveness: 0.1
            },
            force: {
              repulsion: 1000,
              edgeLength: 200
            }
          }]
        };

        this.lineageGraph.setOption(option);
      } catch (error) {
        console.error('åŠ è½½è¡€ç¼˜å…³ç³»å¤±è´¥', error);
      }
    },

    // å¤„ç†è¡€ç¼˜æ•°æ®
    processLineageData(data) {
      const nodes = [];
      const links = [];

      // æ·»åŠ å½“å‰è¡¨èŠ‚ç‚¹
      nodes.push({
        id: data.table.id.toString(),
        name: data.table.tableName,
        category: 0,
        symbolSize: 80,
        itemStyle: {
          color: '#FF6B6B'
        }
      });

      // æ·»åŠ ä¸Šæ¸¸èŠ‚ç‚¹
      data.upstream.forEach((item, index) => {
        const nodeId = `upstream_${index}`;
        nodes.push({
          id: nodeId,
          name: item.node.nodeName,
          category: 1,
          itemStyle: {
            color: '#4ECDC4'
          }
        });

        links.push({
          source: nodeId,
          target: data.table.id.toString(),
          value: item.edgeType
        });
      });

      // æ·»åŠ ä¸‹æ¸¸èŠ‚ç‚¹
      data.downstream.forEach((item, index) => {
        const nodeId = `downstream_${index}`;
        nodes.push({
          id: nodeId,
          name: item.node.nodeName,
          category: 2,
          itemStyle: {
            color: '#45B7D1'
          }
        });

        links.push({
          source: data.table.id.toString(),
          target: nodeId,
          value: item.edgeType
        });
      });

      return { nodes, links };
    },

    // æŸ¥çœ‹è´¨é‡æŠ¥å‘Š
    async viewQuality(tableId) {
      this.qualityDialogVisible = true;

      try {
        const response = await this.$http.get(`/api/quality/table/${tableId}/report`);
        this.qualityReport = response.data;
      } catch (error) {
        console.error('åŠ è½½è´¨é‡æŠ¥å‘Šå¤±è´¥', error);
      }
    },

    // è·å–è´¨é‡æ ‡ç­¾ç±»å‹
    getQualityTagType(score) {
      if (score >= 90) return 'success';
      if (score >= 70) return 'warning';
      return 'danger';
    },

    // åˆ·æ–°æ•°æ®
    refreshData() {
      this.loadOverview();
      this.loadTableList();
      this.loadQualityTrend();
      this.loadClassificationData();
    },

    // åˆ†é¡µå¤„ç†
    handleSizeChange(val) {
      this.pageSize = val;
      this.loadTableList();
    },

    handleCurrentChange(val) {
      this.currentPage = val;
      this.loadTableList();
    }
  }
}
</script>

<style scoped>
.data-governance-dashboard {
  padding: 20px;
}

.dashboard-card {
  text-align: center;
}

.card-content {
  display: flex;
  align-items: center;
  justify-content: center;
}

.card-content .icon-database,
.card-content .icon-quality,
.card-content .icon-lineage,
.card-content .icon-security {
  font-size: 48px;
  margin-right: 20px;
}

.card-info h3 {
  margin: 0;
  font-size: 24px;
  color: #303133;
}

.card-info p {
  margin: 5px 0 0 0;
  font-size: 14px;
  color: #909399;
}
</style>
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

1. [Apache Atlas å®˜æ–¹æ–‡æ¡£](https://atlas.apache.org/)
2. [DataHub å®˜æ–¹æ–‡æ¡£](https://datahubproject.io/)
3. [Apache Griffin å®˜æ–¹æ–‡æ¡£](https://griffin.apache.org/)
4. [æ•°æ®æ²»ç†æœ€ä½³å®è·µ](https://www.dama.org/)
5. [GDPR æ•°æ®ä¿æŠ¤æŒ‡å—](https://gdpr.eu/)

---

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

### å…ƒæ•°æ®ç®¡ç†
- [ ] æ•°æ®æºé…ç½®å®Œæˆ
- [ ] å…ƒæ•°æ®æ‰«æä»»åŠ¡é…ç½®
- [ ] ä¸šåŠ¡æœ¯è¯­è¡¨å»ºç«‹
- [ ] æ•°æ®æ ‡ç­¾ä½“ç³»å»ºç«‹

### æ•°æ®è´¨é‡ç®¡ç†
- [ ] è´¨é‡è§„åˆ™é…ç½®å®Œæˆ
- [ ] è´¨é‡æ£€æŸ¥ä»»åŠ¡è°ƒåº¦
- [ ] è´¨é‡æŠ¥å‘Šè‡ªåŠ¨ç”Ÿæˆ
- [ ] è´¨é‡å‘Šè­¦é…ç½®

### æ•°æ®è¡€ç¼˜ç®¡ç†
- [ ] ETLä½œä¸šè¡€ç¼˜è®°å½•
- [ ] è¡€ç¼˜å…³ç³»å›¾å¯è§†åŒ–
- [ ] å½±å“åˆ†æåŠŸèƒ½
- [ ] å˜æ›´ä¼ æ’­è¿½è¸ª

### æ•°æ®å®‰å…¨
- [ ] æ•æ„Ÿæ•°æ®è§„åˆ™é…ç½®
- [ ] æ•æ„Ÿæ•°æ®è‡ªåŠ¨å‘ç°
- [ ] æ•°æ®è„±æ•ç­–ç•¥
- [ ] è®¿é—®æƒé™æ§åˆ¶

### å¹³å°å»ºè®¾
- [ ] ç®¡ç†ç•Œé¢å¼€å‘
- [ ] APIæœåŠ¡å®Œå–„
- [ ] ç›‘æ§å‘Šè­¦é…ç½®
- [ ] æ–‡æ¡£ç¼–å†™å®Œæˆ

---

**ç¼–åˆ¶ï¼š** æµ®æµ®é…± ğŸ±ï¼ˆçŒ«å¨˜å·¥ç¨‹å¸ˆï¼‰
**æ—¥æœŸï¼š** 2025-11-15
**çŠ¶æ€ï¼š** ğŸ“‹ æŒ‡å—å®Œæˆï¼Œå‡†å¤‡å®æ–½

**åŠ æ²¹å–µï½ æ•°æ®æ²»ç†å¹³å°å³å°†å®Œæˆï¼** à¸…'Ï‰'à¸…
