package com.basebackend.security.vuln;

import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.time.LocalDateTime;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

/**
 * 漏洞扫描定时任务
 * 自动执行定期安全扫描
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class VulnerabilityScanScheduler {

    private final VulnerabilityScanService scanService;
    private final VulnerabilityMapper vulnerabilityMapper;

    /**
     * 每日凌晨2点执行全量扫描
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void performDailyFullScan() {
        log.info("开始执行每日全量漏洞扫描...");

        try {
            // 获取所有需要扫描的项目
            List<String> projects = getAllProjects();

            for (String projectName : projects) {
                ScanRequest request = createScanRequest(projectName, true);
                ScanResult result = scanService.performFullScan(request);

                log.info("项目 {} 扫描完成: 发现漏洞 {} 个",
                        projectName, result.getTotalVulnerabilities());

                // 发送高危漏洞告警
                if (result.getCriticalCount() > 0 || result.getHighCount() > 0) {
                    sendHighSeverityAlert(projectName, result);
                }
            }

            log.info("每日全量漏洞扫描完成");

        } catch (Exception e) {
            log.error("每日全量扫描执行失败", e);
        }
    }

    /**
     * 每6小时执行一次快速扫描
     */
    @Scheduled(cron = "0 0 */6 * * ?")
    public void performQuickScan() {
        log.info("开始执行快速漏洞扫描...");

        try {
            List<String> criticalProjects = getCriticalProjects();

            for (String projectName : criticalProjects) {
                ScanRequest request = createScanRequest(projectName, false);
                ScanResult result = scanService.performFullScan(request);

                log.info("项目 {} 快速扫描完成: 发现漏洞 {} 个",
                        projectName, result.getTotalVulnerabilities());
            }

            log.info("快速漏洞扫描完成");

        } catch (Exception e) {
            log.error("快速扫描执行失败", e);
        }
    }

    /**
     * 每周一上午9点执行依赖组件扫描
     */
    @Scheduled(cron = "0 0 9 ? * MON")
    public void performWeeklyDependencyScan() {
        log.info("开始执行每周依赖组件扫描...");

        try {
            List<String> projects = getAllProjects();

            for (String projectName : projects) {
                ScanRequest request = createDependencyScanRequest(projectName);
                ScanResult result = scanService.performFullScan(request);

                log.info("项目 {} 依赖扫描完成: 发现漏洞 {} 个",
                        projectName, result.getTotalVulnerabilities());
            }

            log.info("每周依赖组件扫描完成");

        } catch (Exception e) {
            log.error("依赖组件扫描执行失败", e);
        }
    }

    /**
     * 检查并更新已知漏洞数据库
     */
    @Scheduled(cron = "0 0 3 * * ?")
    public void updateVulnerabilityDatabase() {
        log.info("开始更新已知漏洞数据库...");

        try {
            // TODO: 从NVD、CVE等数据源更新漏洞数据库
            log.info("漏洞数据库更新完成");

        } catch (Exception e) {
            log.error("漏洞数据库更新失败", e);
        }
    }

    /**
     * 生成每周漏洞报告
     */
    @Scheduled(cron = "0 0 8 ? * MON")
    public void generateWeeklyReport() {
        log.info("开始生成每周漏洞报告...");

        try {
            LocalDateTime startTime = LocalDateTime.now().minusDays(7);
            List<Vulnerability> recentVulns = vulnerabilityMapper.selectRecentVulnerabilities(startTime, 1000);

            String report = generateWeeklyReport(recentVulns);
            log.info("每周漏洞报告已生成");

            // TODO: 发送报告邮件或保存到文件系统

        } catch (Exception e) {
            log.error("生成每周报告失败", e);
        }
    }

    /**
     * 检查长期未修复的高危漏洞
     */
    @Scheduled(fixedRate = 3600000) // 每小时检查一次
    public void checkLongStandingVulnerabilities() {
        log.debug("检查长期未修复的高危漏洞...");

        try {
            List<Vulnerability> unfixedHigh = vulnerabilityMapper.selectUnfixedHighSeverity();
            LocalDateTime threshold = LocalDateTime.now().minusDays(7);

            for (Vulnerability vuln : unfixedHigh) {
                if (vuln.getDiscoveredAt().isBefore(threshold)) {
                    log.warn("发现长期未修复的高危漏洞: {} (发现于: {})",
                            vuln.getName(), vuln.getDiscoveredAt());

                    // TODO: 发送告警通知
                }
            }

        } catch (Exception e) {
            log.error("检查长期未修复漏洞失败", e);
        }
    }

    /**
     * 创建全量扫描请求
     */
    private ScanRequest createScanRequest(String projectName, boolean fullScan) {
        ScanRequest request = new ScanRequest();
        request.setProjectName(projectName);
        request.setProjectPath("/projects/" + projectName);
        request.setScanBy("SYSTEM");
        request.setScanType(getAllScanTypes());

        if (!fullScan) {
            // 快速扫描只包含关键检查
            Set<ScanType> quickTypes = new HashSet<>();
            quickTypes.add(ScanType.STATIC_ANALYSIS);
            quickTypes.add(ScanType.DEPENDENCY_CHECK);
            request.setScanType(quickTypes);
        }

        request.setModules(Arrays.asList("core", "web", "api"));

        return request;
    }

    /**
     * 创建依赖扫描请求
     */
    private ScanRequest createDependencyScanRequest(String projectName) {
        ScanRequest request = new ScanRequest();
        request.setProjectName(projectName);
        request.setProjectPath("/projects/" + projectName);
        request.setScanBy("SYSTEM");
        request.setScanType(new HashSet<>(Arrays.asList(
                ScanType.DEPENDENCY_CHECK
        )));
        request.setModules(Arrays.asList("core", "web", "api"));

        return request;
    }

    /**
     * 获取所有扫描类型
     */
    private Set<ScanType> getAllScanTypes() {
        return new HashSet<>(Arrays.asList(
                ScanType.STATIC_ANALYSIS,
                ScanType.DYNAMIC_TESTING,
                ScanType.DEPENDENCY_CHECK,
                ScanType.CONFIG_AUDIT
        ));
    }

    /**
     * 获取所有需要扫描的项目
     */
    private List<String> getAllProjects() {
        // TODO: 从数据库或配置中获取项目列表
        return Arrays.asList(
                "basebackend-admin-api",
                "basebackend-web",
                "basebackend-gateway",
                "basebackend-user-service",
                "basebackend-auth-service"
        );
    }

    /**
     * 获取关键项目列表
     */
    private List<String> getCriticalProjects() {
        // TODO: 从数据库或配置中获取关键项目列表
        return Arrays.asList(
                "basebackend-admin-api",
                "basebackend-auth-service"
        );
    }

    /**
     * 发送高危漏洞告警
     */
    private void sendHighSeverityAlert(String projectName, ScanResult result) {
        log.warn("项目 {} 发现高危漏洞 - 严重: {}, 高危: {}",
                projectName, result.getCriticalCount(), result.getHighCount());

        // TODO: 集成邮件、企业微信、钉钉等告警渠道
        // - 发送邮件给安全团队
        // - 发送企业微信/钉钉通知
        // - 生成JIRA工单
    }

    /**
     * 生成每周报告
     */
    private String generateWeeklyReport(List<Vulnerability> vulnerabilities) {
        StringBuilder report = new StringBuilder();

        report.append("# 每周安全漏洞报告\n\n");
        report.append("生成时间: ").append(LocalDateTime.now()).append("\n\n");

        // 统计信息
        long total = vulnerabilities.size();
        long critical = vulnerabilities.stream()
                .filter(v -> v.getSeverity() == Vulnerability.Severity.CRITICAL)
                .count();
        long high = vulnerabilities.stream()
                .filter(v -> v.getSeverity() == Vulnerability.Severity.HIGH)
                .count();
        long medium = vulnerabilities.stream()
                .filter(v -> v.getSeverity() == Vulnerability.Severity.MEDIUM)
                .count();
        long low = vulnerabilities.stream()
                .filter(v -> v.getSeverity() == Vulnerability.Severity.LOW)
                .count();

        report.append("## 漏洞统计\n\n");
        report.append("- 总计: ").append(total).append("\n");
        report.append("- 严重: ").append(critical).append("\n");
        report.append("- 高危: ").append(high).append("\n");
        report.append("- 中危: ").append(medium).append("\n");
        report.append("- 低危: ").append(low).append("\n\n");

        // 高危漏洞列表
        report.append("## 高危漏洞列表\n\n");
        vulnerabilities.stream()
                .filter(v -> v.getSeverity() == Vulnerability.Severity.CRITICAL ||
                            v.getSeverity() == Vulnerability.Severity.HIGH)
                .forEach(v -> {
                    report.append("### ").append(v.getName()).append("\n");
                    report.append("- 类型: ").append(v.getType()).append("\n");
                    report.append("- CVSS: ").append(v.getCvssScore()).append("\n");
                    report.append("- 发现时间: ").append(v.getDiscoveredAt()).append("\n\n");
                });

        return report.toString();
    }
}
