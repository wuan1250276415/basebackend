# Phase 14.3: æ™ºèƒ½åŒ–é£æ§å®æ–½æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•æ„å»ºä¼ä¸šçº§æ™ºèƒ½åŒ–é£æ§å¹³å°ï¼Œé€šè¿‡AIæŠ€æœ¯å®ç°å®æ—¶é£æ§æ£€æµ‹ã€æ™ºèƒ½åæ¬ºè¯ˆã€å®‰å…¨å®¡è®¡ç­‰åŠŸèƒ½ï¼Œä¿éšœä¸šåŠ¡å®‰å…¨ï¼Œé™ä½æ¬ºè¯ˆé£é™©ï¼Œæ»¡è¶³ç›‘ç®¡åˆè§„è¦æ±‚ã€‚

---

## ğŸ›¡ï¸ æ™ºèƒ½åŒ–é£æ§æ•´ä½“æ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      æ™ºèƒ½åŒ–é£æ§å¹³å°æ¶æ„                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   å®æ—¶é£æ§     â”‚  â”‚   æ™ºèƒ½åæ¬ºè¯ˆ   â”‚  â”‚   å®‰å…¨å®¡è®¡     â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ å®æ—¶æ£€æµ‹     â”‚  â”‚ â€¢ æ¬ºè¯ˆè¯†åˆ«     â”‚  â”‚ â€¢ è¡Œä¸ºåˆ†æ     â”‚           â”‚
â”‚  â”‚ â€¢ è§„åˆ™å¼•æ“     â”‚  â”‚ â€¢ æ¨¡å¼è¯†åˆ«     â”‚  â”‚ â€¢ å¼‚å¸¸æ£€æµ‹     â”‚           â”‚
â”‚  â”‚ â€¢ æœºå™¨å­¦ä¹      â”‚  â”‚ â€¢ å…³è”åˆ†æ     â”‚  â”‚ â€¢ å®¡è®¡æ—¥å¿—     â”‚           â”‚
â”‚  â”‚ â€¢ å®æ—¶å†³ç­–     â”‚  â”‚ â€¢ è®¾å¤‡æŒ‡çº¹     â”‚  â”‚ â€¢ åˆè§„æ£€æŸ¥     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   ç‰¹å¾å·¥ç¨‹     â”‚  â”‚   æ¨¡å‹ç®¡ç†     â”‚  â”‚   å¨èƒæƒ…æŠ¥     â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ ç‰¹å¾æå–     â”‚  â”‚ â€¢ æ¨¡å‹è®­ç»ƒ     â”‚  â”‚ â€¢ å¨èƒæ£€æµ‹     â”‚           â”‚
â”‚  â”‚ â€¢ ç‰¹å¾é€‰æ‹©     â”‚  â”‚ â€¢ æ¨¡å‹éƒ¨ç½²     â”‚  â”‚ â€¢ æƒ…æŠ¥èåˆ     â”‚           â”‚
â”‚  â”‚ â€¢ ç‰¹å¾å­˜å‚¨     â”‚  â”‚ â€¢ æ¨¡å‹æ›´æ–°     â”‚  â”‚ â€¢ é£é™©è¯„åˆ†     â”‚           â”‚
â”‚  â”‚ â€¢ å®æ—¶ç‰¹å¾     â”‚  â”‚ â€¢ æ¨¡å‹ç›‘æ§     â”‚  â”‚ â€¢ é»‘åå•ç®¡ç†   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   æ•°æ®é‡‡é›†     â”‚  â”‚   å†³ç­–å¼•æ“     â”‚  â”‚   å“åº”å¼•æ“     â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ äº¤æ˜“æ•°æ®     â”‚  â”‚ â€¢ è§„åˆ™æ‰§è¡Œ     â”‚  â”‚ â€¢ è‡ªåŠ¨é˜»æ–­     â”‚           â”‚
â”‚  â”‚ â€¢ è¡Œä¸ºæ•°æ®     â”‚  â”‚ â€¢ æ¨¡å‹æ¨ç†     â”‚  â”‚ â€¢ äººå·¥å®¡æ ¸     â”‚           â”‚
â”‚  â”‚ â€¢ è®¾å¤‡æ•°æ®     â”‚  â”‚ â€¢ å†³ç­–èåˆ     â”‚  â”‚ â€¢ å‘Šè­¦é€šçŸ¥     â”‚           â”‚
â”‚  â”‚ â€¢ ç½‘ç»œæ•°æ®     â”‚  â”‚ â€¢ é£é™©åˆ†çº§     â”‚  â”‚ â€¢ å¤„ç½®æµç¨‹     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   å®æ—¶å­˜å‚¨     â”‚  â”‚   æ¨¡å‹å­˜å‚¨     â”‚  â”‚   å®¡è®¡å­˜å‚¨     â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ Kafka      â”‚  â”‚ â€¢ MLflow     â”‚  â”‚ â€¢ åŒºå—é“¾     â”‚           â”‚
â”‚  â”‚ â€¢ Redis      â”‚  â”‚ â€¢ ModelDB    â”‚  â”‚ â€¢ ES         â”‚           â”‚
â”‚  â”‚ â€¢ ClickHouse â”‚  â”‚ â€¢ TensorFlow â”‚  â”‚ â€¢ MySQL      â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                    æ™ºèƒ½åŒ–é£æ§ç‰¹æ€§                               â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ â€¢ å®æ—¶æ£€æµ‹ï¼šæ¯«ç§’çº§é£æ§å“åº”ï¼Œ100mså†…å®Œæˆé£é™©è¯„ä¼°                  â”‚ â”‚
â”‚  â”‚ â€¢ ç²¾å‡†è¯†åˆ«ï¼šæ¬ºè¯ˆè¯†åˆ«å‡†ç¡®ç‡â‰¥95%ï¼Œè¯¯æŠ¥ç‡â‰¤3%                       â”‚ â”‚
â”‚  â”‚ â€¢ è‡ªé€‚åº”å­¦ä¹ ï¼šæ ¹æ®æ–°å¨èƒè‡ªåŠ¨æ›´æ–°æ£€æµ‹æ¨¡å‹                         â”‚ â”‚
â”‚  â”‚ â€¢ å…¨é¢å®¡è®¡ï¼šå®Œæ•´çš„æ“ä½œå®¡è®¡æ—¥å¿—ï¼Œæ»¡è¶³ç›‘ç®¡è¦æ±‚                     â”‚ â”‚
â”‚  â”‚ â€¢ å¤šç»´é˜²æŠ¤ï¼šè®¾å¤‡ã€è¡Œä¸ºã€ç½‘ç»œã€ä¸šåŠ¡å››ç»´ç«‹ä½“é˜²æŠ¤                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€æœ¯æ ˆé€‰å‹

| å±‚æ¬¡ | æŠ€æœ¯ç»„ä»¶ | ç‰ˆæœ¬ | ç”¨é€” |
|------|----------|------|------|
| **å®æ—¶é£æ§** | Apache Flink | 1.17.1 | å®æ—¶æµå¤„ç† |
| | Apache Kafka | 3.5.0 | å®æ—¶æ•°æ®æµ |
| | Redis Streams | 7.2 | å®æ—¶é˜Ÿåˆ— |
| | Drools | 7.73.0 | è§„åˆ™å¼•æ“ |
| **æœºå™¨å­¦ä¹ ** | TensorFlow | 2.14.0 | æ·±åº¦å­¦ä¹ æ¨¡å‹ |
| | PyTorch | 2.1.0 | æ·±åº¦å­¦ä¹ å¼€å‘ |
| | scikit-learn | 1.3.0 | ä¼ ç»ŸMLç®—æ³• |
| | XGBoost | 2.0.3 | æ¢¯åº¦æå‡ |
| **ç‰¹å¾å·¥ç¨‹** | Feature Store | 0.10.0 | ç‰¹å¾ç®¡ç† |
| | Apache Beam | 2.50.0 | æ‰¹æµç‰¹å¾è®¡ç®— |
| | Redis | 7.2 | å®æ—¶ç‰¹å¾ç¼“å­˜ |
| **æ¨¡å‹ç®¡ç†** | MLflow | 2.7.1 | æ¨¡å‹ç”Ÿå‘½å‘¨æœŸ |
| | Kubeflow | 1.8.0 | MLå¹³å° |
| | Seldon Core | 1.15.0 | æ¨¡å‹æœåŠ¡åŒ– |
| **å¨èƒæƒ…æŠ¥** | OpenCTI | 5.11.0 | å¨èƒæƒ…æŠ¥å¹³å° |
| | MISP | 2.4.168 | æ¶æ„è½¯ä»¶ä¿¡æ¯å…±äº« |
| | VirusTotal | API v3 | æ¶æ„æ–‡ä»¶æ£€æµ‹ |
| **å®‰å…¨å®¡è®¡** | Elasticsearch | 8.11.0 | æ—¥å¿—å­˜å‚¨æœç´¢ |
| | Kibana | 8.11.0 | æ—¥å¿—å¯è§†åŒ– |
| | Auditd | 3.0 | ç³»ç»Ÿå®¡è®¡ |
| | Hyperledger Fabric | 2.4 | åŒºå—é“¾å®¡è®¡ |
| **å†³ç­–å¼•æ“** | Easy Rules | 4.3.0 | è½»é‡çº§è§„åˆ™ |
| | TensorFlow Serving | 2.14.0 | æ¨¡å‹æœåŠ¡åŒ– |
| | gRPC | 1.59.0 | é«˜æ€§èƒ½RPC |

---

## ğŸš¨ å®æ—¶é£æ§å¼•æ“

### 1. é£æ§å¼•æ“æ¶æ„

```java
/**
 * å®æ—¶é£æ§å¼•æ“
 * æ”¯æŒè§„åˆ™å¼•æ“ã€æœºå™¨å­¦ä¹ æ¨¡å‹ã€å®æ—¶å†³ç­–èåˆ
 */
@Service
public class RealTimeRiskEngine {

    @Autowired
    private RuleEngine ruleEngine;

    @Autowired
    private MLModelService mlModelService;

    @Autowired
    private FeatureService featureService;

    @Autowired
    private DecisionEngine decisionEngine;

    @Autowired
    private RiskResponseEngine responseEngine;

    /**
     * å®æ—¶é£æ§æ£€æµ‹
     */
    public RiskDecision makeRiskDecision(RiskContext context) {
        long startTime = System.currentTimeMillis();

        try {
            // 1. ç‰¹å¾æå–ä¸å®æ—¶è®¡ç®—
            RiskFeatures features = featureService.extractRiskFeatures(context);

            // 2. è§„åˆ™å¼•æ“å†³ç­–
            RuleBasedDecision ruleDecision = ruleEngine.evaluateRules(context, features);

            // 3. æœºå™¨å­¦ä¹ æ¨¡å‹å†³ç­–
            MLBasedDecision mlDecision = mlModelService.predictRisk(features);

            // 4. å®æ—¶æµå¤„ç†è¡¥å……ç‰¹å¾
            features = enrichFeaturesFromStream(features, context);

            // 5. å†³ç­–èåˆ
            RiskDecision fusedDecision = fuseDecisions(ruleDecision, mlDecision, features);

            // 6. é£é™©åˆ†çº§
            RiskLevel riskLevel = calculateRiskLevel(fusedDecision);

            // 7. å†³ç­–è§£é‡Š
            DecisionExplanation explanation = generateDecisionExplanation(
                fusedDecision, features, ruleDecision, mlDecision
            );

            // 8. å“åº”å¤„ç†
            RiskResponse response = responseEngine.processRiskDecision(
                context, fusedDecision, riskLevel
            );

            // 9. è®°å½•é£æ§æ—¥å¿—
            logRiskDecision(context, fusedDecision, riskLevel, response);

            RiskDecision result = RiskDecision.builder()
                .contextId(context.getContextId())
                .decision(fusedDecision)
                .riskLevel(riskLevel)
                .explanation(explanation)
                .response(response)
                .processingTime(System.currentTimeMillis() - startTime)
                .timestamp(Instant.now())
                .build();

            return result;

        } catch (Exception e) {
            log.error("å®æ—¶é£æ§å†³ç­–å¤±è´¥", e);

            // å¤±è´¥æ—¶è¿”å›é»˜è®¤å®‰å…¨å†³ç­–
            RiskDecision fallbackDecision = RiskDecision.builder()
                .contextId(context.getContextId())
                .decision(RiskDecisionEnum.REVIEW)
                .riskLevel(RiskLevel.MEDIUM)
                .explanation(DecisionExplanation.builder()
                    .reason("é£æ§ç³»ç»Ÿå¼‚å¸¸ï¼Œé‡‡ç”¨ä¿å®ˆç­–ç•¥")
                    .build())
                .processingTime(System.currentTimeMillis() - startTime)
                .timestamp(Instant.now())
                .build();

            responseEngine.processFallbackDecision(context, fallbackDecision);
            return fallbackDecision;
        }
    }

    /**
     * å®æ—¶ç‰¹å¾å¢å¼º
     */
    private RiskFeatures enrichFeaturesFromStream(RiskFeatures features,
                                                  RiskContext context) {
        try {
            // ä»Kafkaæµä¸­è·å–å®æ—¶ç‰¹å¾
            Map<String, Object> streamFeatures = StreamFeatureExtractor.extractFeatures(
                context.getUserId(),
                context.getDeviceId(),
                context.getTransactionId()
            );

            // åˆå¹¶ç‰¹å¾
            RiskFeatures enrichedFeatures = RiskFeatures.builder()
                .baseFeatures(features.getBaseFeatures())
                .streamFeatures(streamFeatures)
                .calculatedAt(Instant.now())
                .build();

            return enrichedFeatures;

        } catch (Exception e) {
            log.warn("ç‰¹å¾å¢å¼ºå¤±è´¥ï¼Œä½¿ç”¨åŸºç¡€ç‰¹å¾", e);
            return features;
        }
    }

    /**
     * å†³ç­–èåˆç­–ç•¥
     */
    private RiskDecision fuseDecisions(RuleBasedDecision ruleDecision,
                                       MLBasedDecision mlDecision,
                                       RiskFeatures features) {
        // æ ¹æ®é£é™©åœºæ™¯é€‰æ‹©èåˆç­–ç•¥
        switch (context.getScenarioType()) {
            case TRANSACTION:
                return fuseTransactionRisk(ruleDecision, mlDecision, features);
            case LOGIN:
                return fuseLoginRisk(ruleDecision, mlDecision, features);
            case REGISTRATION:
                return fuseRegistrationRisk(ruleDecision, mlDecision, features);
            case PAYMENT:
                return fusePaymentRisk(ruleDecision, mlDecision, features);
            default:
                return fuseDefaultRisk(ruleDecision, mlDecision, features);
        }
    }

    /**
     * äº¤æ˜“é£é™©èåˆ
     */
    private RiskDecision fuseTransactionRisk(RuleBasedDecision ruleDecision,
                                            MLBasedDecision mlDecision,
                                            RiskFeatures features) {
        // äº¤æ˜“åœºæ™¯ï¼šè§„åˆ™ä¼˜å…ˆï¼ŒMLéªŒè¯
        if (ruleDecision.getRiskScore() >= 80) {
            return RiskDecision.builder()
                .decision(RiskDecisionEnum.REJECT)
                .riskScore(ruleDecision.getRiskScore())
                .confidence(0.95)
                .primaryReason(ruleDecision.getPrimaryRule())
                .build();
        }

        // MLæ¨¡å‹å†³ç­–
        double finalScore = mlDecision.getRiskScore() * 0.7 + ruleDecision.getRiskScore() * 0.3;
        RiskDecisionEnum decision = finalScore >= 60 ? RiskDecisionEnum.REVIEW :
                                   finalScore >= 30 ? RiskDecisionEnum.FLAG :
                                   RiskDecisionEnum.APPROVE;

        return RiskDecision.builder()
            .decision(decision)
            .riskScore(finalScore)
            .confidence(mlDecision.getConfidence())
            .primaryReason(mlDecision.getPrimaryFeature())
            .build();
    }
}

/**
 * è§„åˆ™å¼•æ“å®ç°
 */
@Component
public class RuleEngine {

    @Autowired
    private KieContainer kieContainer;

    /**
     * è§„åˆ™è¯„ä¼°
     */
    public RuleBasedDecision evaluateRules(RiskContext context, RiskFeatures features) {
        try {
            // 1. åˆ›å»ºè§„åˆ™ä¼šè¯
            KieSession kieSession = kieContainer.newKieSession("riskRuleSession");

            // 2. æ’å…¥äº‹å®å¯¹è±¡
            kieSession.insert(context);
            kieSession.insert(features);
            kieSession.insert(features.getBaseFeatures());
            kieSession.insert(features.getDeviceFeatures());
            kieSession.insert(features.getBehaviorFeatures());

            // 3. æ‰§è¡Œè§„åˆ™
            int rulesFired = kieSession.fireAllRules();

            // 4. æå–å†³ç­–ç»“æœ
            RuleBasedDecision decision = extractDecision(kieSession);

            kieSession.dispose();

            return decision;

        } catch (Exception e) {
            log.error("è§„åˆ™è¯„ä¼°å¤±è´¥", e);
            throw new RuleEngineException(e);
        }
    }

    /**
     * åŠ¨æ€è§„åˆ™åŠ è½½
     */
    @EventListener
    public void handleDynamicRuleUpdate(DynamicRuleUpdateEvent event) {
        try {
            // 1. åˆ é™¤æ—§çš„KieModule
            KieRepository repo = kieContainer.getKieRepository();
            repo.removeKieModule(event.getOldModuleName());

            // 2. åŠ è½½æ–°è§„åˆ™
            KieModule newModule = createKieModuleFromString(event.getRuleContent());
            repo.addKieModule(newModule);

            // 3. é‡æ–°æ„å»ºKieContainer
            kieContainer = createNewKieContainer(newModule);

            log.info("åŠ¨æ€è§„åˆ™æ›´æ–°æˆåŠŸ: {}", event.getRuleName());

        } catch (Exception e) {
            log.error("åŠ¨æ€è§„åˆ™æ›´æ–°å¤±è´¥", e);
            throw new RuleUpdateException(e);
        }
    }
}

/**
 * è§„åˆ™å®šä¹‰ç¤ºä¾‹
 */
@DecisionTable(
    sheetName = "TransactionRiskRules",
    decisionTablePolicy = DecisionTablePolicy.HIT_POLICY_FIRST
)
public class TransactionRiskRules {

    @Condition("amount > $1")
    @Action("increaseRiskScore($1)")
    public static RuleResult highAmountTransaction(double amount) {
        return null;
    }

    @Condition("transactionHour < 6 || transactionHour > 22")
    @Action("increaseRiskScore(20)")
    public static RuleResult unusualTimeTransaction(TransactionContext context) {
        return null;
    }

    @Condition("!isTrustedLocation(location)")
    @Action("increaseRiskScore(25)")
    public static RuleResult unusualLocationTransaction(TransactionContext context) {
        return null;
    }

    @Condition("velocityTransactions > 5")
    @Action("increaseRiskScore(30)")
    public static RuleResult highVelocityTransactions(TransactionContext context) {
        return null;
    }

    @Condition("isBlacklistedDevice(deviceId)")
    @Action("setDecision(REJECT)")
    public static RuleResult blacklistedDevice(TransactionContext context) {
        return null;
    }

    @Condition("riskScore >= 80")
    @Action("setDecision(REJECT)")
    public static RuleResult highRiskScore(RiskFeatures features) {
        return null;
    }
}
```

### 2. æœºå™¨å­¦ä¹ é£æ§æ¨¡å‹

```java
/**
 * æœºå™¨å­¦ä¹ é£æ§æ¨¡å‹æœåŠ¡
 */
@Service
public class MLModelService {

    @Autowired
    private TensorFlowModelLoader tfModelLoader;

    @Autowired
    private XGBoostModelLoader xgbModelLoader;

    @Autowired
    private FeatureService featureService;

    /**
     * å®æ—¶é£é™©é¢„æµ‹
     */
    public MLBasedDecision predictRisk(RiskFeatures features) {
        try {
            // 1. ç‰¹å¾é¢„å¤„ç†
            PreprocessedFeatures preprocessed = preprocessFeatures(features);

            // 2. é›†æˆæ¨¡å‹é¢„æµ‹
            Map<ModelType, PredictionResult> predictions = new HashMap<>();

            // TensorFlowæ·±åº¦å­¦ä¹ æ¨¡å‹
            predictions.put(ModelType.DEEP_LEARNING, deepLearningPredict(preprocessed));

            // XGBoostæ¨¡å‹
            predictions.put(ModelType.XGBOOST, xgboostPredict(preprocessed));

            // é€»è¾‘å›å½’æ¨¡å‹
            predictions.put(ModelType.LOGISTIC_REGRESSION, logisticRegressionPredict(preprocessed));

            // 3. æ¨¡å‹èåˆ
            PredictionResult fusedPrediction = fusePredictions(predictions);

            // 4. ç”Ÿæˆå†³ç­–
            RiskDecisionEnum decision = decisionFromPrediction(fusedPrediction);

            return MLBasedDecision.builder()
                .decision(decision)
                .riskScore(fusedPrediction.getScore())
                .confidence(fusedPrediction.getConfidence())
                .modelType(ModelType.ENSEMBLE)
                .primaryFeature(fusedPrediction.getPrimaryFeature())
                .featureImportance(fusedPrediction.getFeatureImportance())
                .predictionTime(Instant.now())
                .build();

        } catch (Exception e) {
            log.error("MLæ¨¡å‹é¢„æµ‹å¤±è´¥", e);
            throw new MLModelException(e);
        }
    }

    /**
     * æ·±åº¦å­¦ä¹ æ¨¡å‹é¢„æµ‹
     */
    private PredictionResult deepLearningPredict(PreprocessedFeatures features) {
        try {
            // åŠ è½½SavedModel
            TensorFlowModel model = tfModelLoader.loadModel("models/transaction_risk_deep");

            // æ„å»ºè¾“å…¥å¼ é‡
            Tensor inputTensor = convertFeaturesToTensor(features);

            // æ‰§è¡Œé¢„æµ‹
            Tensor outputTensor = model.predict(inputTensor);

            // è§£æç»“æœ
            return parsePredictionResult(outputTensor);

        } catch (Exception e) {
            log.error("æ·±åº¦å­¦ä¹ æ¨¡å‹é¢„æµ‹å¤±è´¥", e);
            return PredictionResult.builder().build();
        }
    }

    /**
     * åœ¨çº¿æ¨¡å‹è®­ç»ƒ
     */
    @Async
    public CompletableFuture<Void> trainOnlineModel(RiskTrainingData data) {
        return CompletableFuture.runAsync(() -> {
            try {
                log.info("å¼€å§‹åœ¨çº¿æ¨¡å‹è®­ç»ƒ");

                // 1. ç‰¹å¾å·¥ç¨‹
                TrainingDataset dataset = featureService.buildTrainingDataset(data);

                // 2. æ¨¡å‹è®­ç»ƒ
                TrainingConfig config = TrainingConfig.builder()
                    .modelType(ModelType.XGBOOST)
                    .learningRate(0.1)
                    .maxDepth(6)
                    .numRounds(100)
                    .earlyStoppingRounds(10)
                    .build();

                XGBoostModel model = XGBoostModel.train(dataset, config);

                // 3. æ¨¡å‹éªŒè¯
                ValidationMetrics metrics = validateModel(model, dataset.getTestSet());

                // 4. æ¨¡å‹éƒ¨ç½²
                if (metrics.getAUC() > 0.85) {
                    deployModel(model, metrics);
                    log.info("æ¨¡å‹è®­ç»ƒå®Œæˆï¼ŒAUC: {}", metrics.getAUC());
                } else {
                    log.warn("æ¨¡å‹æ€§èƒ½ä¸è¾¾æ ‡ï¼ŒAUC: {}", metrics.getAUC());
                }

            } catch (Exception e) {
                log.error("åœ¨çº¿æ¨¡å‹è®­ç»ƒå¤±è´¥", e);
                notificationService.sendModelTrainingFailure(e);
            }
        });
    }
}

/**
 * æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹
 */
@Service
public class FraudDetectionModel {

    @Autowired
    private GraphNeuralNetwork gnnModel;

    @Autowired
    private SequenceModel sequenceModel;

    /**
     * æ¬ºè¯ˆæ¨¡å¼è¯†åˆ«
     */
    public FraudDetectionResult detectFraudPattern(RiskFeatures features) {
        // 1. å›¾ç»“æ„ç‰¹å¾æå–
        GraphFeatures graphFeatures = extractGraphFeatures(features);

        // 2. GNNæ¨¡å‹é¢„æµ‹
        GNNPrediction gnnPrediction = gnnModel.predict(graphFeatures);

        // 3. åºåˆ—æ¨¡å¼è¯†åˆ«
        SequencePattern pattern = sequenceModel.identifyPattern(features);

        // 4. ç»¼åˆåˆ¤æ–­
        double fraudScore = calculateFraudScore(gnnPrediction, pattern);

        FraudType fraudType = classifyFraudType(gnnPrediction, pattern);

        return FraudDetectionResult.builder()
            .fraudScore(fraudScore)
            .fraudType(fraudType)
            .pattern(pattern.getPatternType())
            .confidence(Math.max(gnnPrediction.getConfidence(), pattern.getConfidence()))
            .explanation(generateFraudExplanation(gnnPrediction, pattern))
            .build();
    }

    /**
     * è®¾å¤‡æŒ‡çº¹æ¬ºè¯ˆæ£€æµ‹
     */
    @Service
    public class DeviceFingerprintDetector {

        /**
         * è®¾å¤‡æŒ‡çº¹ç”Ÿæˆä¸æ£€æµ‹
         */
        public DeviceFingerprintResult detectDeviceFingerprint(String deviceInfo) {
            // 1. æŒ‡çº¹ç‰¹å¾æå–
            DeviceFingerprintFeatures features = extractDeviceFeatures(deviceInfo);

            // 2. æŒ‡çº¹ç›¸ä¼¼åº¦è®¡ç®—
            List<DeviceFingerprint> historical = getHistoricalFingerprints(
                features.getUserId()
            );

            List<SimilarityMatch> matches = calculateSimilarity(features, historical);

            // 3. å¼‚å¸¸è®¾å¤‡æ£€æµ‹
            boolean isNewDevice = isNewDevice(features);
            double noveltyScore = calculateNoveltyScore(features, historical);

            // 4. è®¾å¤‡å˜è„¸æ£€æµ‹
            List<DeviceFaceChange> changes = detectDeviceFaceChange(
                features.getDeviceId()
            );

            return DeviceFingerprintResult.builder()
                .deviceId(features.getDeviceId())
                .fingerprint(features.getFingerprint())
                .isNewDevice(isNewDevice)
                .noveltyScore(noveltyScore)
                .similarityMatches(matches)
                .deviceChanges(changes)
                .riskLevel(calculateDeviceRiskLevel(isNewDevice, noveltyScore, changes))
                .build();
        }

        /**
         * è®¾å¤‡æŒ‡çº¹ç›¸ä¼¼åº¦è®¡ç®—
         */
        private List<SimilarityMatch> calculateSimilarity(DeviceFingerprintFeatures features,
                                                         List<DeviceFingerprint> historical) {
            return historical.stream()
                .map(historicalFp -> SimilarityMatch.builder()
                    .historicalFingerprint(historicalFp)
                    .similarityScore(calculateJaccardSimilarity(
                        features.getFingerprint(),
                        historicalFp.getFingerprint()
                    ))
                    .similarityFeatures(compareFeatureVectors(
                        features.getFeatureVector(),
                        historicalFp.getFeatureVector()
                    ))
                    .lastSeen(historicalFp.getLastSeen())
                    .build())
                .filter(match -> match.getSimilarityScore() > 0.7)
                .sorted(Comparator.comparing(SimilarityMatch::getSimilarityScore).reversed())
                .collect(Collectors.toList());
        }
    }
}
```

---

## ğŸ” æ™ºèƒ½åæ¬ºè¯ˆç³»ç»Ÿ

### 1. æ¬ºè¯ˆæ£€æµ‹å¼•æ“

```java
/**
 * æ™ºèƒ½åæ¬ºè¯ˆç³»ç»Ÿ
 */
@Service
public class IntelligentAntiFraudSystem {

    @Autowired
    private FraudDetectionModel fraudDetectionModel;

    @Autowired
    private DeviceFingerprintDetector deviceDetector;

    @Autowired
    private BehaviorAnalysisEngine behaviorEngine;

    @Autowired
    private GraphAnalysisEngine graphEngine;

    @Autowired
    private ThreatIntelligenceService threatIntelligence;

    /**
     * ç»¼åˆåæ¬ºè¯ˆæ£€æµ‹
     */
    public FraudDetectionResult detectFraud(TransactionRequest request) {
        try {
            // 1. å¤šç»´åº¦ç‰¹å¾æå–
            FraudFeatures features = extractFraudFeatures(request);

            // 2. å®æ—¶æ¬ºè¯ˆæ£€æµ‹
            FraudDetectionResult result = FraudDetectionResult.builder()
                .transactionId(request.getTransactionId())
                .userId(request.getUserId())
                .build();

            // è®¾å¤‡ç»´åº¦æ£€æµ‹
            DeviceFingerprintResult deviceResult = deviceDetector.detectDeviceFingerprint(
                request.getDeviceInfo()
            );
            result.setDeviceAnalysis(deviceResult);

            // è¡Œä¸ºç»´åº¦æ£€æµ‹
            BehaviorAnalysisResult behaviorResult = behaviorEngine.analyzeBehavior(
                request.getUserId(), request.getCurrentRequest()
            );
            result.setBehaviorAnalysis(behaviorResult);

            // äº¤æ˜“ç»´åº¦æ£€æµ‹
            TransactionFraudResult transactionResult = analyzeTransactionFraud(features);
            result.setTransactionAnalysis(transactionResult);

            // å›¾åˆ†ææ£€æµ‹
            GraphFraudResult graphResult = graphEngine.analyzeFraudNetwork(
                request.getUserId(), features
            );
            result.setGraphAnalysis(graphResult);

            // å¨èƒæƒ…æŠ¥æ£€æµ‹
            ThreatIntelligenceResult threatResult = threatIntelligence.analyzeThreat(
                request.getUserId(), request.getDeviceInfo()
            );
            result.setThreatAnalysis(threatResult);

            // 3. ç»¼åˆé£é™©è¯„åˆ†
            double riskScore = calculateComprehensiveRiskScore(
                deviceResult, behaviorResult, transactionResult, graphResult, threatResult
            );

            // 4. æ¬ºè¯ˆç±»å‹è¯†åˆ«
            FraudType fraudType = identifyFraudType(
                deviceResult, behaviorResult, transactionResult, graphResult
            );

            // 5. ç”Ÿæˆå†³ç­–
            FraudDecision decision = generateFraudDecision(riskScore, fraudType, result);

            result.setRiskScore(riskScore);
            result.setFraudType(fraudType);
            result.setDecision(decision);

            // 6. è®°å½•æ£€æµ‹æ—¥å¿—
            logFraudDetection(result);

            return result;

        } catch (Exception e) {
            log.error("åæ¬ºè¯ˆæ£€æµ‹å¤±è´¥", e);
            return generateFallbackFraudResult(request);
        }
    }

    /**
     * äº¤æ˜“ç»´åº¦æ¬ºè¯ˆåˆ†æ
     */
    private TransactionFraudResult analyzeTransactionFraud(FraudFeatures features) {
        // 1. äº¤æ˜“é‡‘é¢å¼‚å¸¸æ£€æµ‹
        AmountAnomaly amountAnomaly = detectAmountAnomaly(features);

        // 2. äº¤æ˜“æ—¶é—´å¼‚å¸¸æ£€æµ‹
        TimeAnomaly timeAnomaly = detectTimeAnomaly(features);

        // 3. äº¤æ˜“é¢‘ç‡å¼‚å¸¸æ£€æµ‹
        FrequencyAnomaly frequencyAnomaly = detectFrequencyAnomaly(features);

        // 4. äº¤æ˜“æ¨¡å¼å¼‚å¸¸æ£€æµ‹
        PatternAnomaly patternAnomaly = detectPatternAnomaly(features);

        // 5. åœ°ç†å¼‚å¸¸æ£€æµ‹
        GeoAnomaly geoAnomaly = detectGeoAnomaly(features);

        return TransactionFraudResult.builder()
            .amountAnomaly(amountAnomaly)
            .timeAnomaly(timeAnomaly)
            .frequencyAnomaly(frequencyAnomaly)
            .patternAnomaly(patternAnomaly)
            .geoAnomaly(geoAnomaly)
            .overallScore(calculateTransactionRiskScore(
                amountAnomaly, timeAnomaly, frequencyAnomaly, patternAnomaly, geoAnomaly
            ))
            .build();
    }

    /**
     * äº¤æ˜“é‡‘é¢å¼‚å¸¸æ£€æµ‹
     */
    private AmountAnomaly detectAmountAnomaly(FraudFeatures features) {
        Transaction transaction = features.getTransaction();

        // 1. å†å²ç»Ÿè®¡åˆ†æ
        AmountStatistics stats = getAmountStatistics(features.getUserId());

        // 2. è®¡ç®—Z-score
        double zScore = calculateZScore(transaction.getAmount(), stats);

        // 3. ç›¸å¯¹å˜åŒ–ç‡æ£€æµ‹
        double changeRate = calculateRelativeChange(
            transaction.getAmount(),
            stats.getMedianAmount()
        );

        // 4. åˆ†å¸ƒåç¦»æ£€æµ‹
        double distributionDistance = calculateDistributionDistance(
            transaction.getAmount(),
            stats.getHistoricalDistribution()
        );

        boolean isAnomaly = Math.abs(zScore) > 3 ||
                           changeRate > 5 ||
                           distributionDistance > 0.8;

        return AmountAnomaly.builder()
            .isAnomaly(isAnomaly)
            .zScore(zScore)
            .changeRate(changeRate)
            .distributionDistance(distributionDistance)
            .anomalyType(AmountAnomalyType.valueOf(zScore))
            .riskLevel(isAnomaly ? RiskLevel.HIGH : RiskLevel.LOW)
            .explanation(generateAmountAnomalyExplanation(zScore, changeRate, distributionDistance))
            .build();
    }
}

/**
 * å›¾åˆ†ææ¬ºè¯ˆæ£€æµ‹
 */
@Service
public class GraphAnalysisEngine {

    @Autowired
    private GraphDatabase graphDatabase;

    @Autowired
    private GraphNeuralNetwork gnnModel;

    /**
     * æ¬ºè¯ˆç½‘ç»œåˆ†æ
     */
    public GraphFraudResult analyzeFraudNetwork(String userId, FraudFeatures features) {
        // 1. æ„å»ºç”¨æˆ·å›¾è°±
        UserGraph userGraph = buildUserGraph(userId);

        // 2. å›¾ç‰¹å¾æå–
        GraphFeatures graphFeatures = extractGraphFeatures(userGraph);

        // 3. GNNæ¨¡å‹é¢„æµ‹
        GNNPrediction prediction = gnnModel.predict(graphFeatures);

        // 4. ç¤¾åŒºæ£€æµ‹
        List<Community> communities = detectCommunities(userGraph);

        // 5. è·¯å¾„åˆ†æ
        List<SuspiciousPath> paths = findSuspiciousPaths(userGraph, features);

        // 6. å½±å“åŠ›åˆ†æ
        InfluenceAnalysis influence = analyzeInfluence(userGraph, userId);

        // 7. å›¢ä¼™æ£€æµ‹
        List<FraudGroup> fraudGroups = detectFraudGroups(communities);

        return GraphFraudResult.builder()
            .userId(userId)
            .graphFeatures(graphFeatures)
            .fraudProbability(prediction.getFraudProbability())
            .suspiciousCommunities(communities.stream()
                .filter(c -> c.getFraudProbability() > 0.7)
                .collect(Collectors.toList()))
            .suspiciousPaths(paths)
            .influenceScore(influence.getInfluenceScore())
            .fraudGroups(fraudGroups)
            .graphRiskLevel(calculateGraphRiskLevel(prediction, communities, paths, fraudGroups))
            .build();
    }

    /**
     * æ„å»ºç”¨æˆ·å›¾è°±
     */
    private UserGraph buildUserGraph(String userId) {
        UserGraph.Builder builder = UserGraph.builder()
            .centerUserId(userId);

        // 1. è·å–ç”¨æˆ·å…³è”å…³ç³»
        List<UserRelation> relations = graphDatabase.getUserRelations(userId);

        for (UserRelation relation : relations) {
            builder.addNode(relation.getRelatedUserId(), relation.getRelationType());

            // æ·»åŠ è¾¹çš„ç‰¹å¾
            builder.addEdge(
                userId,
                relation.getRelatedUserId(),
                relation.getRelationType(),
                relation.getStrength(),
                relation.getFirstInteraction(),
                relation.getLastInteraction()
            );
        }

        // 2. æ·»åŠ è®¾å¤‡å…³è”
        List<DeviceRelation> deviceRelations = graphDatabase.getDeviceRelations(userId);
        for (DeviceRelation deviceRel : deviceRelations) {
            builder.addDeviceNode(deviceRel.getDeviceId(), deviceRel.getDeviceType());
            builder.addEdge(userId, deviceRel.getDeviceId(), RelationType.USE_DEVICE, 1.0);
        }

        // 3. æ·»åŠ IPå…³è”
        List<IPRelation> ipRelations = graphDatabase.getIPRelations(userId);
        for (IPRelation ipRel : ipRelations) {
            builder.addIPNode(ipRel.getIpAddress(), ipRel.getGeolocation());
            builder.addEdge(userId, ipRel.getIpAddress(), RelationType.ACCESS_FROM_IP, ipRel.getFrequency());
        }

        return builder.build();
    }

    /**
     * å›¢ä¼™æ¬ºè¯ˆæ£€æµ‹
     */
    private List<FraudGroup> detectFraudGroups(List<Community> communities) {
        return communities.stream()
            .filter(this::isSuspiciousCommunity)
            .map(this::analyzeFraudGroup)
            .filter(Objects::nonNull)
            .collect(Collectors.toList());
    }

    private boolean isSuspiciousCommunity(Community community) {
        // å›¢ä¼™æ£€æµ‹è§„åˆ™
        return community.getSize() >= 3 &&
               community.getFraudProbability() > 0.7 &&
               community.getInternalConnections() > community.getSize() * 1.5;
    }

    private FraudGroup analyzeFraudGroup(Community community) {
        // 1. è®¡ç®—å›¢ä¼™å¯†åº¦
        double density = calculateCommunityDensity(community);

        // 2. åˆ†æå›¢ä¼™ç»“æ„
        CommunityStructure structure = analyzeCommunityStructure(community);

        // 3. æ£€æµ‹å¼‚å¸¸è¡Œä¸ºæ¨¡å¼
        List<AbnormalPattern> patterns = detectAbnormalPatterns(community);

        // 4. è¯„ä¼°å›¢ä¼™é£é™©
        double riskScore = calculateCommunityRiskScore(community, density, patterns);

        if (riskScore > 0.7) {
            return FraudGroup.builder()
                .communityId(community.getId())
                .members(community.getMembers())
                .riskScore(riskScore)
                .density(density)
                .structure(structure)
                .abnormalPatterns(patterns)
                .fraudType(identifyFraudGroupType(structure, patterns))
                .estimatedLoss(estimateFraudLoss(community, patterns))
                .build();
        }

        return null;
    }
}
```

### 2. å®æ—¶æµå¼æ¬ºè¯ˆæ£€æµ‹

```java
/**
 * å®æ—¶æµå¼æ¬ºè¯ˆæ£€æµ‹ç³»ç»Ÿ
 */
@Service
public class StreamFraudDetectionService {

    @Autowired
    private FlinkExecutionEnvironment flinkEnv;

    @Autowired
    private KafkaSource kafkaSource;

    @Autowired
    private RedisFeatureStore redisFeatureStore;

    /**
     * å®æ—¶äº¤æ˜“æµæ¬ºè¯ˆæ£€æµ‹
     */
    public void startRealTimeFraudDetection() {
        // 1. åˆ›å»ºæµå¤„ç†ç¯å¢ƒ
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();

        // 2. é…ç½®æ£€æŸ¥ç‚¹
        env.enableCheckpointing(5000);
        env.getCheckpointConfig().setCheckpointTimeout(60000);

        // 3. é…ç½®Kafkaæº
        DataStream<TransactionEvent> transactionStream = env
            .addSource(kafkaSource.getTransactionSource())
            .name("transaction-source");

        // 4. å®æ—¶ç‰¹å¾æå–
        DataStream<TransactionFeatures> featureStream = transactionStream
            .keyBy(event -> event.getUserId())
            .process(new RealTimeFeatureExtractionFunction())
            .name("feature-extraction");

        // 5. å®æ—¶æ¬ºè¯ˆæ£€æµ‹
        DataStream<FraudDetectionResult> fraudStream = featureStream
            .keyBy(features -> features.getUserId())
            .process(new RealTimeFraudDetectionFunction())
            .name("fraud-detection");

        // 6. å®æ—¶å“åº”å¤„ç†
        fraudStream.addSink(new FraudResponseSink())
            .name("fraud-response");

        // 7. ç»“æœè¾“å‡ºåˆ°å¤–éƒ¨ç³»ç»Ÿ
        fraudStream.addSink(new FraudResultSink())
            .name("fraud-result-sink");

        try {
            env.execute("RealTimeFraudDetectionJob");
        } catch (Exception e) {
            log.error("æµå¼æ¬ºè¯ˆæ£€æµ‹ä»»åŠ¡å¯åŠ¨å¤±è´¥", e);
        }
    }

    /**
     * å®æ—¶ç‰¹å¾æå–å‡½æ•°
     */
    public static class RealTimeFeatureExtractionFunction
            extends KeyedProcessFunction<String, TransactionEvent, TransactionFeatures> {

        private ValueState<TransactionHistory> historyState;

        @Override
        public void open(Configuration parameters) throws Exception {
            historyState = getRuntimeContext().getState(
                new ValueStateDescriptor<>("transaction-history", TransactionHistory.class)
            );
        }

        @Override
        public void processElement(TransactionEvent event,
                                  Context ctx,
                                  Collector<TransactionFeatures> out) throws Exception {
            // 1. è·å–å†å²äº¤æ˜“è®°å½•
            TransactionHistory history = historyState.value();
            if (history == null) {
                history = new TransactionHistory();
            }

            // 2. æ›´æ–°å†å²è®°å½•
            history.addTransaction(event);

            // 3. è®¡ç®—å®æ—¶ç‰¹å¾
            TransactionFeatures features = calculateRealTimeFeatures(event, history);

            // 4. ä¿å­˜å†å²çŠ¶æ€
            historyState.update(history);

            out.collect(features);
        }

        private TransactionFeatures calculateRealTimeFeatures(TransactionEvent event,
                                                             TransactionHistory history) {
            // é€Ÿåº¦ç‰¹å¾
            double velocity1min = history.getTransactionVelocity(Duration.ofMinutes(1));
            double velocity10min = history.getTransactionVelocity(Duration.ofMinutes(10));
            double velocity1hour = history.getTransactionVelocity(Duration.ofHours(1));

            // é‡‘é¢ç‰¹å¾
            double avgAmount1hour = history.getAverageAmount(Duration.ofHours(1));
            double amountStdDev1day = history.getAmountStdDev(Duration.ofDays(1));

            // åœ°ç†ç‰¹å¾
            double geoDistance = calculateGeoDistance(
                event.getLocation(),
                history.getLastLocation()
            );

            // æ—¶é—´ç‰¹å¾
            int hourOfDay = event.getTimestamp().getHour();
            boolean isWeekend = event.getTimestamp().getDayOfWeek().getValue() >= 6;
            boolean isNightTime = hourOfDay < 6 || hourOfDay > 22;

            return TransactionFeatures.builder()
                .transactionId(event.getTransactionId())
                .userId(event.getUserId())
                .amount(event.getAmount())
                .location(event.getLocation())
                .velocity1min(velocity1min)
                .velocity10min(velocity10min)
                .velocity1hour(velocity1hour)
                .avgAmount1hour(avgAmount1hour)
                .amountStdDev1day(amountStdDev1day)
                .geoDistance(geoDistance)
                .hourOfDay(hourOfDay)
                .isWeekend(isWeekend)
                .isNightTime(isNightTime)
                .deviceFingerprint(event.getDeviceFingerprint())
                .build();
        }
    }

    /**
     * å®æ—¶æ¬ºè¯ˆæ£€æµ‹å‡½æ•°
     */
    public static class RealTimeFraudDetectionFunction
            extends KeyedProcessFunction<String, TransactionFeatures, FraudDetectionResult> {

        @Autowired
        private FraudDetectionModel fraudModel;

        @Autowired
        private RuleEngine ruleEngine;

        private TimerState lastDetectionTime;

        @Override
        public void open(Configuration parameters) throws Exception {
            lastDetectionTime = new TimerState();
        }

        @Override
        public void processElement(TransactionFeatures features,
                                  Context ctx,
                                  Collector<FraudDetectionResult> out) throws Exception {
            try {
                // 1. è§„åˆ™å¼•æ“æ£€æµ‹
                RuleDetectionResult ruleResult = ruleEngine.detectFraud(features);

                // 2. MLæ¨¡å‹æ£€æµ‹
                MLDetectionResult mlResult = fraudModel.predictFraud(features);

                // 3. å†³ç­–èåˆ
                double riskScore = fuseDetectionResults(ruleResult, mlResult);

                // 4. é£é™©ç­‰çº§åˆ¤å®š
                RiskLevel riskLevel = determineRiskLevel(riskScore);

                // 5. ç”Ÿæˆæ£€æµ‹ç»“æœ
                FraudDetectionResult result = FraudDetectionResult.builder()
                    .transactionId(features.getTransactionId())
                    .userId(features.getUserId())
                    .riskScore(riskScore)
                    .riskLevel(riskLevel)
                    .ruleResult(ruleResult)
                    .mlResult(mlResult)
                    .detectionTime(Instant.now())
                    .build();

                out.collect(result);

            } catch (Exception e) {
                log.error("å®æ—¶æ¬ºè¯ˆæ£€æµ‹å¤±è´¥", e);

                // å¼‚å¸¸æƒ…å†µè¿”å›ä¿å®ˆç»“æœ
                FraudDetectionResult fallbackResult = FraudDetectionResult.builder()
                    .transactionId(features.getTransactionId())
                    .userId(features.getUserId())
                    .riskScore(70.0)
                    .riskLevel(RiskLevel.MEDIUM)
                    .detectionTime(Instant.now())
                    .build();

                out.collect(fallbackResult);
            }
        }
    }
}
```

---

## ğŸ”’ æ™ºèƒ½å®‰å…¨å®¡è®¡ç³»ç»Ÿ

### 1. å®¡è®¡æ—¥å¿—æ”¶é›†

```java
/**
 * æ™ºèƒ½å®‰å…¨å®¡è®¡ç³»ç»Ÿ
 */
@Service
public class IntelligentSecurityAudit {

    @Autowired
    private AuditLogCollector auditLogCollector;

    @Autowired
    private AuditAnalysisEngine auditAnalysisEngine;

    @Autowired
    private ComplianceChecker complianceChecker;

    @Autowired
    private BlockchainAuditLog blockchainAuditLog;

    /**
     * è®°å½•å®¡è®¡æ—¥å¿—
     */
    public void recordAuditLog(AuditEvent event) {
        try {
            // 1. å®æ—¶åˆ†æ
            AuditAnalysisResult analysis = auditAnalysisEngine.analyzeRealtime(event);

            // 2. åˆè§„æ£€æŸ¥
            ComplianceCheckResult compliance = complianceChecker.checkCompliance(event);

            // 3. é£é™©è¯„ä¼°
            AuditRiskAssessment risk = assessAuditRisk(event, analysis);

            // 4. å¤šå±‚å­˜å‚¨
            // 4.1 å†™å…¥å®¡è®¡æ—¥å¿—åº“
            persistAuditLog(event, analysis, compliance);

            // 4.2 å†™å…¥åŒºå—é“¾ï¼ˆä¸å¯ç¯¡æ”¹ï¼‰
            if (event.getSecurityLevel() == SecurityLevel.HIGH) {
                blockchainAuditLog.recordEvent(event);
            }

            // 5. å‘Šè­¦å¤„ç†
            if (risk.getRiskLevel() == RiskLevel.HIGH) {
                sendSecurityAlert(event, analysis, risk);
            }

            // 6. å®æ—¶ç›‘æ§
            updateSecurityDashboard(event, analysis, compliance);

        } catch (Exception e) {
            log.error("å®¡è®¡æ—¥å¿—è®°å½•å¤±è´¥", e);
        }
    }

    /**
     * è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
     */
    @Service
    public class BehaviorAnomalyDetector {

        /**
         * ç”¨æˆ·è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
         */
        public BehaviorAnomalyResult detectBehaviorAnomaly(UserBehaviorEvent event) {
            // 1. è·å–ç”¨æˆ·è¡Œä¸ºåŸºçº¿
            BehaviorBaseline baseline = getUserBehaviorBaseline(event.getUserId());

            // 2. è¡Œä¸ºç‰¹å¾æå–
            BehaviorFeatures features = extractBehaviorFeatures(event, baseline);

            // 3. å¼‚å¸¸æ£€æµ‹ç®—æ³•
            List<AnomalyType> anomalies = detectBehaviorAnomalies(features);

            // 4. é£é™©è¯„åˆ†
            double riskScore = calculateBehaviorRiskScore(features, anomalies);

            // 5. ç”Ÿæˆæ£€æµ‹ç»“æœ
            return BehaviorAnomalyResult.builder()
                .userId(event.getUserId())
                .eventId(event.getEventId())
                .anomalies(anomalies)
                .riskScore(riskScore)
                .riskLevel(riskLevelFromScore(riskScore))
                .features(features)
                .baseline(baseline)
                .detectionTime(Instant.now())
                .build();
        }

        /**
         * ç™»å½•è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
         */
        public LoginAnomalyResult detectLoginAnomaly(LoginEvent event) {
            LoginAnomalyResult.Builder result = LoginAnomalyResult.builder()
                .userId(event.getUserId())
                .loginTime(event.getLoginTime())
                .ipAddress(event.getIpAddress())
                .deviceInfo(event.getDeviceInfo());

            // 1. åœ°ç†ä½ç½®å¼‚å¸¸
            GeoAnomaly geoAnomaly = detectGeoAnomaly(event);
            if (geoAnomaly.isAnomaly()) {
                result.addAnomaly(AnomalyType.GEOGRAPHIC_ANOMALY);
            }

            // 2. æ—¶é—´å¼‚å¸¸
            TimeAnomaly timeAnomaly = detectLoginTimeAnomaly(event);
            if (timeAnomaly.isAnomaly()) {
                result.addAnomaly(AnomalyType.TIME_ANOMALY);
            }

            // 3. è®¾å¤‡å¼‚å¸¸
            DeviceAnomaly deviceAnomaly = detectDeviceAnomaly(event);
            if (deviceAnomaly.isAnomaly()) {
                result.addAnomaly(AnomalyType.DEVICE_ANOMALY);
            }

            // 4. é¢‘ç‡å¼‚å¸¸
            FrequencyAnomaly freqAnomaly = detectLoginFrequencyAnomaly(event);
            if (freqAnomaly.isAnomaly()) {
                result.addAnomaly(AnomalyType.FREQUENCY_ANOMALY);
            }

            // 5. ç»¼åˆè¯„åˆ†
            double riskScore = calculateLoginRiskScore(geoAnomaly, timeAnomaly, deviceAnomaly, freqAnomaly);
            result.riskScore(riskScore);
            result.riskLevel(riskLevelFromScore(riskScore));

            return result.build();
        }

        /**
         * åœ°ç†ä½ç½®å¼‚å¸¸æ£€æµ‹
         */
        private GeoAnomaly detectGeoAnomaly(LoginEvent event) {
            // 1. è·å–å†å²ç™»å½•ä½ç½®
            List<LoginLocation> historicalLocations = getHistoricalLoginLocations(
                event.getUserId(), Duration.ofDays(30)
            );

            // 2. è®¡ç®—è·ç¦»
            double distance = calculateDistance(event.getLocation(), getLastLoginLocation(historicalLocations));

            // 3. è®¡ç®—é€Ÿåº¦å¼‚å¸¸
            Instant lastLogin = getLastLoginTime(historicalLocations);
            double hoursDiff = Duration.between(lastLogin, event.getLoginTime()).toHours();
            double requiredSpeed = hoursDiff > 0 ? distance / hoursDiff : 0;

            // 4. å¼‚å¸¸åˆ¤å®š
            boolean isAnomaly = distance > 1000 || requiredSpeed > 1000; // è·ç¦»>1000kmæˆ–é€Ÿåº¦>1000km/h

            return GeoAnomaly.builder()
                .isAnomaly(isAnomaly)
                .distance(distance)
                .requiredSpeed(requiredSpeed)
                .isPhysicallyImpossible(requiredSpeed > 900) // éŸ³é€Ÿ
                .riskLevel(isAnomaly ? RiskLevel.MEDIUM : RiskLevel.LOW)
                .build();
        }
    }
}

/**
 * åŒºå—é“¾å®¡è®¡æ—¥å¿—
 */
@Service
public class BlockchainAuditLog {

    @Autowired
    private HyperledgerFabricClient fabricClient;

    @Autowired
    private SmartContractClient contractClient;

    /**
     * è®°å½•ä¸å¯ç¯¡æ”¹å®¡è®¡æ—¥å¿—
     */
    public void recordEvent(AuditEvent event) {
        try {
            // 1. äº‹ä»¶å“ˆå¸Œè®¡ç®—
            String eventHash = calculateEventHash(event);

            // 2. åŒºå—é“¾äº¤æ˜“æ„é€ 
            BlockchainTransaction transaction = BlockchainTransaction.builder()
                .eventId(event.getEventId())
                .userId(event.getUserId())
                .eventType(event.getEventType())
                .eventHash(eventHash)
                .eventData(event.getEventData())
                .timestamp(event.getTimestamp())
                .signature(event.getSignature())
                .build();

            // 3. æäº¤åˆ°åŒºå—é“¾
            TransactionResult result = contractClient.submitTransaction(
                "auditLogContract",
                "recordEvent",
                transaction.toBytes()
            );

            // 4. éªŒè¯äº¤æ˜“
            if (result.isSuccess()) {
                // 5. æ›´æ–°æœ¬åœ°ç´¢å¼•
                updateLocalIndex(event, result.getTransactionId());

                log.info("å®¡è®¡æ—¥å¿—å·²ä¸Šé“¾: {}", event.getEventId());
            } else {
                log.error("å®¡è®¡æ—¥å¿—ä¸Šé“¾å¤±è´¥: {}", result.getErrorMessage());
            }

        } catch (Exception e) {
            log.error("åŒºå—é“¾å®¡è®¡æ—¥å¿—è®°å½•å¤±è´¥", e);
        }
    }

    /**
     * å®¡è®¡æ—¥å¿—éªŒè¯
     */
    public AuditLogVerification verifyAuditLog(String eventId) {
        try {
            // 1. æŸ¥è¯¢é“¾ä¸Šæ—¥å¿—
            byte[] chainLog = contractClient.evaluateTransaction(
                "auditLogContract",
                "getEvent",
                eventId
            );

            AuditEvent chainEvent = AuditEvent.fromBytes(chainLog);

            // 2. ä»æœ¬åœ°æ•°æ®åº“è·å–æ—¥å¿—
            AuditEvent localEvent = getLocalAuditLog(eventId);

            // 3. éªŒè¯æ•°æ®ä¸€è‡´æ€§
            boolean isConsistent = verifyDataConsistency(chainEvent, localEvent);

            // 4. éªŒè¯å“ˆå¸Œå€¼
            boolean isHashValid = verifyEventHash(chainEvent);

            // 5. éªŒè¯ç­¾å
            boolean isSignatureValid = verifyEventSignature(chainEvent);

            return AuditLogVerification.builder()
                .eventId(eventId)
                .isConsistent(isConsistent)
                .isHashValid(isHashValid)
                .isSignatureValid(isSignatureValid)
                .verificationTime(Instant.now())
                .build();

        } catch (Exception e) {
            log.error("å®¡è®¡æ—¥å¿—éªŒè¯å¤±è´¥", e);
            return AuditLogVerification.builder()
                .eventId(eventId)
                .isConsistent(false)
                .verificationError(e.getMessage())
                .verificationTime(Instant.now())
                .build();
        }
    }
}
```

---

## ğŸ“‹ å®æ–½æ£€æŸ¥æ¸…å•

### å®æ—¶é£æ§å¼•æ“
- [ ] é£æ§å¼•æ“æ¶æ„è®¾è®¡å®Œæˆ
- [ ] è§„åˆ™å¼•æ“é›†æˆï¼ˆDroolsï¼‰
- [ ] æœºå™¨å­¦ä¹ æ¨¡å‹æœåŠ¡åŒ–
- [ ] å®æ—¶ç‰¹å¾è®¡ç®—ï¼ˆFlinkï¼‰
- [ ] å†³ç­–èåˆç­–ç•¥å®ç°
- [ ] å†³ç­–è§£é‡Šæ¨¡å—å¼€å‘

### æ™ºèƒ½åæ¬ºè¯ˆç³»ç»Ÿ
- [ ] æ¬ºè¯ˆæ£€æµ‹æ¨¡å‹å¼€å‘ï¼ˆæ·±åº¦å­¦ä¹ ã€å›¾ç¥ç»ç½‘ç»œï¼‰
- [ ] è®¾å¤‡æŒ‡çº¹æ£€æµ‹
- [ ] è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
- [ ] å›¾åˆ†æå¼•æ“ï¼ˆå›¢ä¼™æ£€æµ‹ã€è·¯å¾„åˆ†æï¼‰
- [ ] å®æ—¶æµå¼æ£€æµ‹ï¼ˆFlinkï¼‰
- [ ] æ¬ºè¯ˆç±»å‹è¯†åˆ«

### æ™ºèƒ½å®‰å…¨å®¡è®¡
- [ ] å®¡è®¡æ—¥å¿—æ”¶é›†ç³»ç»Ÿ
- [ ] è¡Œä¸ºå¼‚å¸¸æ£€æµ‹
- [ ] åŒºå—é“¾å®¡è®¡æ—¥å¿—
- [ ] åˆè§„æ£€æŸ¥å¼•æ“
- [ ] é£é™©è¯„ä¼°æ¨¡å‹
- [ ] å®‰å…¨å‘Šè­¦ç³»ç»Ÿ

### ç³»ç»Ÿé›†æˆ
- [ ] äº‘å®‰å…¨APIé›†æˆ
- [ ] å¨èƒæƒ…æŠ¥é›†æˆ
- [ ] é»‘åå•ç®¡ç†
- [ ] é£æ§APIæœåŠ¡
- [ ] ç›‘æ§ä»ªè¡¨ç›˜
- [ ] æ€§èƒ½ä¼˜åŒ–

---

**ç¼–åˆ¶ï¼š** æµ®æµ®é…± ğŸ±ï¼ˆçŒ«å¨˜å·¥ç¨‹å¸ˆï¼‰
**æ—¥æœŸï¼š** 2025-11-15
**çŠ¶æ€ï¼š** ğŸ“‹ æŒ‡å—å®Œæˆï¼Œå‡†å¤‡å®æ–½

**åŠ æ²¹å–µï½ æ™ºèƒ½åŒ–é£æ§å¹³å°å³å°†å®Œæˆï¼** à¸…'Ï‰'à¸…
