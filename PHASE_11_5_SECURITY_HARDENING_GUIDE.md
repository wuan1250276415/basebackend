# Phase 11.5: å®‰å…¨åŠ å›ºå®æ–½æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

æœ¬æŒ‡å—ä»‹ç»å¦‚ä½•å…¨é¢åŠ å›ºç³»ç»Ÿå®‰å…¨ï¼ŒåŒ…æ‹¬è®¤è¯å®‰å…¨ã€æ•°æ®å®‰å…¨ã€æ¥å£å®‰å…¨å’Œå®¡è®¡æ—¥å¿—ï¼Œç¡®ä¿ç³»ç»Ÿåœ¨ç”Ÿäº§ç¯å¢ƒä¸­çš„å®‰å…¨æ€§å’Œåˆè§„æ€§ã€‚

---

## ğŸ—ï¸ å®‰å…¨æ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å®‰å…¨åŠ å›ºæ¶æ„                                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   è®¤è¯å®‰å…¨    â”‚  â”‚   æ•°æ®å®‰å…¨    â”‚  â”‚   æ¥å£å®‰å…¨    â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ OAuth 2.0 â”‚  â”‚ â€¢ æ•°æ®åŠ å¯†    â”‚  â”‚ â€¢ API ç­¾å   â”‚           â”‚
â”‚  â”‚ â€¢ JWT Token â”‚  â”‚ â€¢ æ•°æ®è„±æ•    â”‚  â”‚ â€¢ é˜²é‡æ”¾     â”‚           â”‚
â”‚  â”‚ â€¢ MFA       â”‚  â”‚ â€¢ AES-256    â”‚  â”‚ â€¢ é™æµé˜²æŠ¤   â”‚           â”‚
â”‚  â”‚ â€¢ RBAC      â”‚  â”‚ â€¢ å¯†é’¥ç®¡ç†    â”‚  â”‚ â€¢ HTTPS     â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚   å®¡è®¡æ—¥å¿—     â”‚  â”‚   è®¿é—®æ§åˆ¶   â”‚  â”‚   å®‰å…¨ç›‘æ§   â”‚           â”‚
â”‚  â”‚              â”‚  â”‚              â”‚  â”‚              â”‚           â”‚
â”‚  â”‚ â€¢ æ“ä½œè®°å½•    â”‚  â”‚ â€¢ é»‘ç™½åå•   â”‚  â”‚ â€¢ å…¥ä¾µæ£€æµ‹   â”‚           â”‚
â”‚  â”‚ â€¢ åˆè§„è¿½è¸ª    â”‚  â”‚ â€¢ æƒé™æ§åˆ¶   â”‚  â”‚ â€¢ å¼‚å¸¸å‘Šè­¦   â”‚           â”‚
â”‚  â”‚ â€¢ æ—¥å¿—å®¡è®¡    â”‚  â”‚ â€¢ æœ€å°æƒé™   â”‚  â”‚ â€¢ é£é™©è¯„ä¼°   â”‚           â”‚
â”‚  â”‚ â€¢ æ•°æ®è¡€ç¼˜    â”‚  â”‚ â€¢ é›¶ä¿¡ä»»     â”‚  â”‚ â€¢ å®‰å…¨æ€åŠ¿   â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                  å®‰å…¨é˜²æŠ¤å±‚                                  â”‚ â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚
â”‚  â”‚ â€¢ WAF (Web åº”ç”¨é˜²ç«å¢™)                                      â”‚ â”‚
â”‚  â”‚ â€¢ DDoS é˜²æŠ¤                                                 â”‚ â”‚
â”‚  â”‚ â€¢ æ¼æ´æ‰«æ                                                   â”‚ â”‚
â”‚  â”‚ â€¢ å®‰å…¨åŸºçº¿                                                   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®‰å…¨é˜²æŠ¤çŸ©é˜µ

| å®‰å…¨åŸŸ | é˜²æŠ¤æªæ–½ | æŠ€æœ¯å®ç° | ä»·å€¼ |
|--------|----------|----------|------|
| **è®¤è¯å®‰å…¨** | OAuth 2.0ã€JWTã€MFA | Spring Security OAuth2 | èº«ä»½éªŒè¯ |
| **æ•°æ®å®‰å…¨** | AES-256ã€å­—æ®µè„±æ• | Jasyptã€MyBatis åŠ å¯† | æ•°æ®ä¿æŠ¤ |
| **æ¥å£å®‰å…¨** | API ç­¾åã€é˜²é‡æ”¾ | HMAC-SHA256 | API å®‰å…¨ |
| **å®¡è®¡æ—¥å¿—** | æ“ä½œè¿½è¸ªã€åˆè§„è®°å½• | ELK å®¡è®¡ | åˆè§„å®¡è®¡ |
| **è®¿é—®æ§åˆ¶** | RBACã€ABAC | Spring Security ACL | æƒé™æ§åˆ¶ |
| **ç½‘ç»œå®‰å…¨** | HTTPSã€TLS 1.3 | Nginx SSL | ä¼ è¾“å®‰å…¨ |

---

## ğŸ” è®¤è¯å®‰å…¨å®ç°

### 1. OAuth 2.0 + JWT è®¤è¯

#### æ·»åŠ ä¾èµ–

```xml
<!-- Spring Security OAuth2 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-oauth2-client</artifactId>
</dependency>

<!-- Spring Security JWT -->
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.12.3</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.12.3</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.12.3</version>
    <scope>runtime</scope>
</dependency>

<!-- å¯†ç åŠ å¯† -->
<dependency>
    <groupId>org.springframework.security</groupId>
    <artifactId>spring-security-crypto</artifactId>
</dependency>

<!-- éªŒè¯ç  -->
<dependency>
    <groupId>com.github.penggle</groupId>
    <artifactId>kaptcha</artifactId>
    <version>2.3.2</version>
</dependency>
```

#### JWT é…ç½®ç±»

```java
/**
 * JWT å®‰å…¨é…ç½®
 */
@Configuration
@EnableConfigurationProperties(JwtProperties.class)
public class JwtSecurityConfig {

    @Bean
    public JwtTokenProvider jwtTokenProvider(JwtProperties properties) {
        return new JwtTokenProvider(properties);
    }

    @Bean
    public JwtAuthenticationFilter jwtAuthenticationFilter(JwtTokenProvider tokenProvider) {
        return new JwtAuthenticationFilter(tokenProvider);
    }

    @Bean
    public BCryptPasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder(12);
    }
}

/**
 * JWT é…ç½®å±æ€§
 */
@ConfigurationProperties(prefix = "jwt.security")
@Data
public class JwtProperties {

    /**
     * JWT å¯†é’¥ (Base64 ç¼–ç ï¼Œé•¿åº¦ä¸å°‘äº 32 å­—èŠ‚)
     */
    private String secret = "YourSecretKeyMustBeVeryLongAndSecure2024Basebackend2024";

    /**
     * Token æœ‰æ•ˆæœŸ (ç§’ï¼Œé»˜è®¤ 2 å°æ—¶)
     */
    private long expiration = 7200;

    /**
     * Refresh Token æœ‰æ•ˆæœŸ (ç§’ï¼Œé»˜è®¤ 7 å¤©)
     */
    private long refreshExpiration = 604800;

    /**
     * Token å‰ç¼€
     */
    private String tokenPrefix = "Bearer ";

    /**
     * Header åç§°
     */
    private String header = "Authorization";
}

/**
 * JWT Token æä¾›è€…
 */
@Component
public class JwtTokenProvider {

    private final JwtProperties properties;
    private final Key key;

    public JwtTokenProvider(JwtProperties properties) {
        this.properties = properties;
        byte[] keyBytes = Decoders.BASE64.decode(properties.getSecret());
        this.key = Keys.hmacShaKeyFor(keyBytes);
    }

    /**
     * ç”Ÿæˆ Token
     */
    public String generateToken(UserDetails userDetails, Set<String> roles) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("roles", roles);
        claims.put("userId", ((User) userDetails).getId());
        claims.put("username", userDetails.getUsername());

        return createToken(claims, userDetails.getUsername(), properties.getExpiration());
    }

    /**
     * ç”Ÿæˆ Refresh Token
     */
    public String generateRefreshToken(String username) {
        Map<String, Object> claims = new HashMap<>();
        claims.put("type", "refresh");

        return createToken(claims, username, properties.getRefreshExpiration());
    }

    /**
     * åˆ›å»º Token
     */
    private String createToken(Map<String, Object> claims, String subject, long validityInSeconds) {
        Date now = new Date();
        Date validity = new Date(now.getTime() + validityInSeconds * 1000);

        return Jwts.builder()
            .setClaims(claims)
            .setSubject(subject)
            .setIssuedAt(now)
            .setExpiration(validity)
            .signWith(key, SignatureAlgorithm.HS256)
            .compact();
    }

    /**
     * ä» Token ä¸­è·å–ç”¨æˆ·å
     */
    public String getUsernameFromToken(String token) {
        return getClaimsFromToken(token).getSubject();
    }

    /**
     * ä» Token ä¸­è·å–ç”¨æˆ· ID
     */
    public Long getUserIdFromToken(String token) {
        return getClaimsFromToken(token).get("userId", Long.class);
    }

    /**
     * ä» Token ä¸­è·å–è§’è‰²
     */
    @SuppressWarnings("unchecked")
    public Set<String> getRolesFromToken(String token) {
        return getClaimsFromToken(token).get("roles", Set.class);
    }

    /**
     * éªŒè¯ Token
     */
    public boolean validateToken(String token) {
        try {
            getClaimsFromToken(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    /**
     * è§£æ Claims
     */
    private Claims getClaimsFromToken(String token) {
        return Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(token.replace(properties.getTokenPrefix(), ""))
            .getBody();
    }

    /**
     * éªŒè¯ Token æ˜¯å¦è¿‡æœŸ
     */
    public boolean isTokenExpired(String token) {
        try {
            Date expiration = getClaimsFromToken(token).getExpiration();
            return expiration.before(new Date());
        } catch (Exception e) {
            return true;
        }
    }

    /**
     * ä» Header ä¸­æå– Token
     */
    public String resolveToken(HttpServletRequest request) {
        String bearerToken = request.getHeader(properties.getHeader());
        if (StringUtils.hasText(bearerToken) && bearerToken.startsWith(properties.getTokenPrefix())) {
            return bearerToken.substring(properties.getTokenPrefix().length());
        }
        return null;
    }
}

/**
 * JWT è®¤è¯è¿‡æ»¤å™¨
 */
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtTokenProvider tokenProvider;

    public JwtAuthenticationFilter(JwtTokenProvider tokenProvider) {
        this.tokenProvider = tokenProvider;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {
        String token = tokenProvider.resolveToken(request);

        if (StringUtils.hasText(token) && tokenProvider.validateToken(token)) {
            Authentication authentication = createAuthentication(token);
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }

        filterChain.doFilter(request, response);
    }

    /**
     * åˆ›å»ºè®¤è¯ä¿¡æ¯
     */
    private Authentication createAuthentication(String token) {
        Long userId = tokenProvider.getUserIdFromToken(token);
        String username = tokenProvider.getUsernameFromToken(token);
        Set<String> roles = tokenProvider.getRolesFromToken(token);

        User user = new User();
        user.setId(userId);
        user.setUsername(username);
        user.setRoles(roles);

        List<SimpleGrantedAuthority> authorities = roles.stream()
            .map(SimpleGrantedAuthority::new)
            .collect(Collectors.toList());

        return new UsernamePasswordAuthenticationToken(user, null, authorities);
    }
}
```

#### å¤šå› ç´ è®¤è¯ (MFA)

```java
/**
 * å¤šå› ç´ è®¤è¯æœåŠ¡
 */
@Service
public class MfaService {

    private static final int OTP_LENGTH = 6;
    private static final int OTP_VALIDITY_DURATION = 300; // 5 åˆ†é’Ÿ

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Autowired
    private NotificationService notificationService;

    /**
     * ç”Ÿæˆ MFA éªŒè¯ç 
     */
    public MfaCode generateMfaCode(String userId) {
        String code = generateRandomCode();
        String key = "mfa:" + userId;

        // å­˜å‚¨éªŒè¯ç åˆ° Redis
        redisTemplate.opsForValue().set(key, code, OTP_VALIDITY_DURATION, TimeUnit.SECONDS);

        // å‘é€éªŒè¯ç ï¼ˆé‚®ä»¶/çŸ­ä¿¡ï¼‰
        User user = userService.getUserById(userId);
        notificationService.sendMfaCode(user, code);

        return MfaCode.builder()
            .userId(userId)
            .maskedCode(maskCode(code))
            .validityDuration(OTP_VALIDITY_DURATION)
            .build();
    }

    /**
     * éªŒè¯ MFA éªŒè¯ç 
     */
    public boolean verifyMfaCode(String userId, String code) {
        String key = "mfa:" + userId;
        String storedCode = redisTemplate.opsForValue().get(key);

        if (storedCode == null) {
            return false;
        }

        boolean valid = storedCode.equals(code);
        if (valid) {
            // éªŒè¯æˆåŠŸååˆ é™¤éªŒè¯ç 
            redisTemplate.delete(key);
        }

        return valid;
    }

    /**
     * å¯ç”¨ MFA
     */
    public void enableMfa(String userId) {
        User user = userService.getUserById(userId);
        user.setMfaEnabled(true);
        user.setMfaSecret(generateMfaSecret());
        userService.updateUser(user);

        log.info("ç”¨æˆ· {} å·²å¯ç”¨ MFA", userId);
    }

    /**
     * ç¦ç”¨ MFA
     */
    public void disableMfa(String userId) {
        User user = userService.getUserById(userId);
        user.setMfaEnabled(false);
        user.setMfaSecret(null);
        userService.updateUser(user);

        log.warn("ç”¨æˆ· {} å·²ç¦ç”¨ MFA", userId);
    }

    /**
     * éªŒè¯ TOTP (åŸºäºæ—¶é—´çš„ä¸€æ¬¡æ€§å¯†ç )
     */
    public boolean verifyTotp(String userId, String totp) {
        User user = userService.getUserById(userId);
        if (!user.getMfaEnabled() || user.getMfaSecret() == null) {
            return false;
        }

        return verifyTotp(user.getMfaSecret(), totp);
    }

    private boolean verifyTotp(String secret, String totp) {
        // ä½¿ç”¨ Google Authenticator ç®—æ³•éªŒè¯
        long currentTime = System.currentTimeMillis() / 1000 / 30;
        for (int i = -1; i <= 1; i++) {
            String generated = generateTotp(secret, currentTime + i);
            if (generated.equals(totp)) {
                return true;
            }
        }
        return false;
    }

    private String generateTotp(String secret, long time) {
        // TOTP ç®—æ³•å®ç°
        // çœç•¥å…·ä½“å®ç°ï¼Œå»ºè®®ä½¿ç”¨ç°æœ‰çš„åº“
        return "123456";
    }

    private String generateMfaSecret() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[20];
        random.nextBytes(bytes);
        return Base32.encode(bytes);
    }

    private String generateRandomCode() {
        SecureRandom random = new SecureRandom();
        int code = random.nextInt((int) Math.pow(10, OTP_LENGTH));
        return String.format("%0" + OTP_LENGTH + "d", code);
    }

    private String maskCode(String code) {
        if (code.length() <= 2) {
            return "*".repeat(code.length());
        }
        return code.substring(0, 2) + "*".repeat(code.length() - 2);
    }

    @Data
    @Builder
    public static class MfaCode {
        private String userId;
        private String maskedCode;
        private int validityDuration;
    }
}
```

### 2. RBAC æƒé™æ§åˆ¶

```java
/**
 * æƒé™é…ç½®
 */
@Configuration
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {

    @Autowired
    private JwtAuthenticationFilter jwtAuthenticationFilter;

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/auth/**", "/api/public/**").permitAll()
                .requestMatchers(HttpMethod.GET, "/api/user/profile").hasAnyRole("USER", "ADMIN")
                .requestMatchers(HttpMethod.PUT, "/api/user/**").hasRole("USER")
                .requestMatchers("/api/admin/**").hasRole("ADMIN")
                .requestMatchers("/api/audit/**").hasAnyRole("ADMIN", "AUDITOR")
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter.class)
            .oauth2Login(oauth2 -> oauth2
                .loginPage("/login")
                .defaultSuccessUrl("/dashboard")
                .failureUrl("/login?error")
            )
            .logout(logout -> logout
                .logoutUrl("/api/auth/logout")
                .invalidateHttpSession(true)
                .deleteCookies("JSESSIONID")
            );

        return http.build();
    }
}

/**
 * æƒé™æ£€æŸ¥æ³¨è§£
 */
@RestController
@RequestMapping("/api/user")
public class UserController {

    @GetMapping("/profile")
    @PreAuthorize("hasRole('USER') or hasRole('ADMIN')")
    public Result<UserProfile> getProfile(Authentication authentication) {
        User user = (User) authentication.getPrincipal();
        return Result.success(userService.getUserProfile(user.getId()));
    }

    @PutMapping("/profile")
    @PreAuthorize("#userId == authentication.principal.id or hasRole('ADMIN')")
    public Result<Void> updateProfile(@PathVariable Long userId,
                                      @RequestBody @Valid UserUpdateRequest request) {
        userService.updateUserProfile(userId, request);
        return Result.success();
    }

    @DeleteMapping("/{userId}")
    @PreAuthorize("hasRole('ADMIN') and hasPermission(#userId, 'User', 'DELETE')")
    public Result<Void> deleteUser(@PathVariable Long userId) {
        userService.deleteUser(userId);
        return Result.success();
    }
}
```

---

## ğŸ”’ æ•°æ®å®‰å…¨å®ç°

### 1. æ•°æ®åŠ å¯†

#### é…ç½®æ–‡ä»¶åŠ å¯†

```yaml
# application.yml
jasypt:
  encryptor:
    algorithm: PBEWITHHMACSHA512ANDAES_256
    password: ${JASYPT_ENCRYPTOR_PASSWORD}
    key-obtention-iterations: 1000
    pool-size: 1
    salt-generator-classname: org.jasypt.salt.RandomSaltGenerator
    string-output-type: base64

# ä½¿ç”¨ç¤ºä¾‹
spring:
  datasource:
    password: ENC(encrypted_password_here)
  redis:
    password: ENC(encrypted_redis_password)
```

#### å­—æ®µçº§åŠ å¯†

```java
/**
 * æ•°æ®åŠ å¯†æ³¨è§£
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Encrypted {

    /**
     * åŠ å¯†ç®—æ³•
     */
    String algorithm() default "AES/CBC/PKCS5Padding";

    /**
     * å¯†é’¥åç§° (ä»é…ç½®ä¸­è·å–)
     */
    String keyName() default "data.encryption.key";
}

/**
 * åŠ å¯†å­—æ®µå¤„ç†å™¨
 */
@Component
public class EncryptedFieldProcessor {

    private static final Logger log = LoggerFactory.getLogger(EncryptedFieldProcessor.class);

    @Autowired
    private Map<String, Key> encryptionKeys;

    /**
     * åŠ å¯†å­—æ®µå€¼
     */
    public Object encryptField(Object fieldValue, Encrypted annotation) {
        if (fieldValue == null || fieldValue.toString().isEmpty()) {
            return fieldValue;
        }

        try {
            String algorithm = annotation.algorithm();
            Key key = encryptionKeys.get(annotation.keyName());

            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.ENCRYPT_MODE, key);

            byte[] encrypted = cipher.doFinal(fieldValue.toString().getBytes());
            return Base64.getEncoder().encodeToString(encrypted);

        } catch (Exception e) {
            log.error("å­—æ®µåŠ å¯†å¤±è´¥", e);
            throw new SecurityException("æ•°æ®åŠ å¯†å¤±è´¥", e);
        }
    }

    /**
     * è§£å¯†å­—æ®µå€¼
     */
    public Object decryptField(Object fieldValue, Encrypted annotation) {
        if (fieldValue == null || fieldValue.toString().isEmpty()) {
            return fieldValue;
        }

        try {
            if (!isEncrypted(fieldValue.toString())) {
                return fieldValue;
            }

            String algorithm = annotation.algorithm();
            Key key = encryptionKeys.get(annotation.keyName());

            Cipher cipher = Cipher.getInstance(algorithm);
            cipher.init(Cipher.DECRYPT_MODE, key);

            byte[] encrypted = Base64.getDecoder().decode(fieldValue.toString());
            byte[] decrypted = cipher.doFinal(encrypted);

            return new String(decrypted);

        } catch (Exception e) {
            log.error("å­—æ®µè§£å¯†å¤±è´¥", e);
            throw new SecurityException("æ•°æ®è§£å¯†å¤±è´¥", e);
        }
    }

    private boolean isEncrypted(String value) {
        return value != null && value.startsWith("ENC(") && value.endsWith(")");
    }
}

/**
 * ç”¨æˆ·å®ä½“ç±»ï¼ˆæ•æ„Ÿå­—æ®µåŠ å¯†ï¼‰
 */
@Entity
@Table(name = "sys_user")
public class User {

    @Id
    private Long id;

    @Column(nullable = false, unique = true)
    private String username;

    @Encrypted
    @Column(name = "email")
    private String email;

    @Encrypted
    @Column(name = "phone")
    private String phone;

    @Column(name = "password", nullable = false)
    private String password;

    // getter/setter
}

/**
 * æ•°æ®è„±æ•æ³¨è§£
 */
@Target({ElementType.FIELD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Desensitized {

    /**
     * è„±æ•ç±»å‹
     */
    DesensitizationType type();

    /**
     * è‡ªå®šä¹‰è„±æ•è§„åˆ™
     */
    String pattern() default "";
}

/**
 * è„±æ•ç±»å‹æšä¸¾
 */
public enum DesensitizationType {
    // æ‰‹æœºå·ï¼š138****5678
    MOBILE_PHONE,
    // é‚®ç®±ï¼šadmin***@example.com
    EMAIL,
    // èº«ä»½è¯å·ï¼š11010119900101****
    ID_CARD,
    // é“¶è¡Œå¡å·ï¼š6222 **** **** **** 1234
    BANK_CARD,
    // å§“åï¼šå¼ *
    NAME,
    // åœ°å€ï¼šåŒ—äº¬å¸‚æµ·æ·€åŒº****
    ADDRESS
}

/**
 * è„±æ•å·¥å…·ç±»
 */
@Component
public class DesensitizationUtil {

    /**
     * æ•°æ®è„±æ•
     */
    public String desensitize(String value, Desensitized annotation) {
        if (StringUtils.isEmpty(value)) {
            return value;
        }

        switch (annotation.type()) {
            case MOBILE_PHONE:
                return desensitizeMobilePhone(value);
            case EMAIL:
                return desensitizeEmail(value);
            case ID_CARD:
                return desensitizeIdCard(value);
            case BANK_CARD:
                return desensitizeBankCard(value);
            case NAME:
                return desensitizeName(value);
            case ADDRESS:
                return desensitizeAddress(value);
            default:
                return value;
        }
    }

    private String desensitizeMobilePhone(String mobile) {
        if (mobile.length() != 11) {
            return mobile;
        }
        return mobile.substring(0, 3) + "****" + mobile.substring(7);
    }

    private String desensitizeEmail(String email) {
        int atIndex = email.indexOf("@");
        if (atIndex < 1) {
            return email;
        }
        String username = email.substring(0, atIndex);
        String domain = email.substring(atIndex);

        if (username.length() <= 3) {
            return "***" + domain;
        }
        return username.substring(0, 3) + "***" + domain;
    }

    private String desensitizeIdCard(String idCard) {
        if (idCard.length() < 8) {
            return idCard;
        }
        return idCard.substring(0, 6) + "********" + idCard.substring(14);
    }

    private String desensitizeBankCard(String bankCard) {
        if (bankCard.length() < 8) {
            return bankCard;
        }
        return "**** **** **** " + bankCard.substring(bankCard.length() - 4);
    }

    private String desensitizeName(String name) {
        if (name.length() <= 1) {
            return name;
        }
        return name.substring(0, 1) + "*";
    }

    private String desensitizeAddress(String address) {
        if (address.length() < 8) {
            return address;
        }
        return address.substring(0, 4) + "****" + address.substring(address.length() - 2);
    }
}
```

### 2. æ•°æ®åº“å®‰å…¨

```sql
-- åˆ›å»ºåŠ å¯†è¡¨ç©ºé—´
CREATE TABLESPACE encryption_ts
ADD DATAFILE 'encryption_ts.ibd'
FILE_BLOCK_SIZE = 8192
ENCRYPTION = 'Y';

-- åˆ›å»ºåŠ å¯†è¡¨
CREATE TABLE sensitive_data (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  user_id BIGINT NOT NULL,
  encrypted_column VARBINARY(500) NOT NULL,
  encryption_key_id VARCHAR(100) NOT NULL,
  create_time DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3),
  update_time DATETIME(3) DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3),
  INDEX idx_user_id (user_id)
) TABLESPACE=encryption_ts;

-- å¯ç”¨é€æ˜æ•°æ®åŠ å¯† (TDE)
ALTER INSTANCE ROTATE INNODB MASTER KEY;

-- åˆ›å»ºå®¡è®¡è§¦å‘å™¨
DELIMITER //

CREATE TRIGGER audit_user_update
AFTER UPDATE ON sys_user
FOR EACH ROW
BEGIN
  INSERT INTO audit_log (
    table_name, operation, old_values, new_values,
    operator, operator_ip, create_time
  ) VALUES (
    'sys_user', 'UPDATE',
    JSON_OBJECT('email', OLD.email, 'phone', OLD.phone),
    JSON_OBJECT('email', NEW.email, 'phone', NEW.phone),
    @current_user, @current_ip, NOW()
  );
END//

DELIMITER ;
```

---

## ğŸ”— æ¥å£å®‰å…¨å®ç°

### 1. API ç­¾åè®¤è¯

```java
/**
 * API ç­¾åå·¥å…·
 */
@Component
public class ApiSignatureUtil {

    private static final String SIGNATURE_HEADER = "X-API-Signature";
    private static final String TIMESTAMP_HEADER = "X-API-Timestamp";
    private static final String NONCE_HEADER = "X-API-Nonce";
    private static final long TIMESTAMP_VALIDITY = 300000; // 5 åˆ†é’Ÿ

    /**
     * ç”Ÿæˆ API ç­¾å
     */
    public String generateSignature(String secretKey, String method, String uri,
                                   Map<String, String> params, String timestamp, String nonce) {
        // 1. æ‹¼æ¥ç­¾åå­—ç¬¦ä¸²
        StringBuilder signString = new StringBuilder();
        signString.append(method.toUpperCase()).append("\n");
        signString.append(uri).append("\n");

        // 2. æŒ‰å­—å…¸åºæ’åºå‚æ•°
        TreeMap<String, String> sortedParams = new TreeMap<>(params);
        for (Map.Entry<String, String> entry : sortedParams.entrySet()) {
            signString.append(entry.getKey()).append("=").append(entry.getValue()).append("&");
        }

        // 3. ç§»é™¤æœ€åä¸€ä¸ª '&'
        if (sortedParams.size() > 0) {
            signString.setLength(signString.length() - 1);
        }

        // 4. æ·»åŠ æ—¶é—´æˆ³å’Œéšæœºæ•°
        signString.append("\n");
        signString.append(timestamp).append("\n");
        signString.append(nonce);

        // 5. HMAC-SHA256 åŠ å¯†
        try {
            SecretKeySpec keySpec = new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), "HmacSHA256");
            Mac mac = Mac.getInstance("HmacSHA256");
            mac.init(keySpec);
            byte[] bytes = mac.doFinal(signString.toString().getBytes(StandardCharsets.UTF_8));

            return Base64.getEncoder().encodeToString(bytes);
        } catch (Exception e) {
            throw new SecurityException("API ç­¾åç”Ÿæˆå¤±è´¥", e);
        }
    }

    /**
     * éªŒè¯ API ç­¾å
     */
    public boolean verifySignature(String secretKey, String method, String uri,
                                  Map<String, String> params, String signature,
                                  String timestamp, String nonce) {
        // 1. éªŒè¯æ—¶é—´æˆ³
        long requestTime = Long.parseLong(timestamp);
        long currentTime = System.currentTimeMillis();
        if (Math.abs(currentTime - requestTime) > TIMESTAMP_VALIDITY) {
            throw new SecurityException("è¯·æ±‚æ—¶é—´æˆ³å·²è¿‡æœŸ");
        }

        // 2. éªŒè¯éšæœºæ•°ï¼ˆé˜²æ­¢é‡æ”¾æ”»å‡»ï¼‰
        if (!isValidNonce(nonce)) {
            throw new SecurityException("éšæœºæ•°æ— æ•ˆæˆ–å·²ä½¿ç”¨");
        }

        // 3. éªŒè¯ç­¾å
        String expectedSignature = generateSignature(secretKey, method, uri, params, timestamp, nonce);
        return expectedSignature.equals(signature);
    }

    private boolean isValidNonce(String nonce) {
        // æ£€æŸ¥éšæœºæ•°æ˜¯å¦å·²ä½¿ç”¨
        String key = "api:nonce:" + nonce;
        Boolean exists = redisTemplate.hasKey(key);
        if (Boolean.TRUE.equals(exists)) {
            return false; // å·²è¢«ä½¿ç”¨
        }

        // è®°å½•éšæœºæ•°
        redisTemplate.opsForValue().set(key, "1", TIMESTAMP_VALIDITY, TimeUnit.MILLISECONDS);
        return true;
    }

    /**
     * ä»è¯·æ±‚ä¸­æå–ç­¾åä¿¡æ¯
     */
    public SignatureInfo extractSignatureInfo(HttpServletRequest request) {
        String signature = request.getHeader(SIGNATURE_HEADER);
        String timestamp = request.getHeader(TIMESTAMP_HEADER);
        String nonce = request.getHeader(NONCE_HEADER);

        if (signature == null || timestamp == null || nonce == null) {
            throw new IllegalArgumentException("ç¼ºå°‘å¿…è¦çš„ç­¾åå¤´ä¿¡æ¯");
        }

        return SignatureInfo.builder()
            .signature(signature)
            .timestamp(timestamp)
            .nonce(nonce)
            .build();
    }

    @Data
    @Builder
    public static class SignatureInfo {
        private String signature;
        private String timestamp;
        private String nonce;
    }
}

/**
 * API ç­¾åæ‹¦æˆªå™¨
 */
@Component
public class ApiSignatureInterceptor implements HandlerInterceptor {

    @Autowired
    private ApiSignatureUtil signatureUtil;

    @Autowired
    private ApiAuthService apiAuthService;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) {
        // ä»…å¯¹ API è¯·æ±‚è¿›è¡Œç­¾åéªŒè¯
        if (!request.getRequestURI().startsWith("/api/")) {
            return true;
        }

        try {
            SignatureInfo signatureInfo = signatureUtil.extractSignatureInfo(request);

            // è·å– API å¯†é’¥
            String apiKey = request.getHeader("X-API-Key");
            String secretKey = apiAuthService.getSecretKey(apiKey);

            if (secretKey == null) {
                throw new SecurityException("æ— æ•ˆçš„ API å¯†é’¥");
            }

            // éªŒè¯ç­¾å
            String method = request.getMethod();
            String uri = request.getRequestURI();
            Map<String, String> params = extractParams(request);

            boolean valid = signatureUtil.verifySignature(
                secretKey, method, uri, params,
                signatureInfo.getSignature(),
                signatureInfo.getTimestamp(),
                signatureInfo.getNonce()
            );

            if (!valid) {
                throw new SecurityException("API ç­¾åéªŒè¯å¤±è´¥");
            }

            // å°† API å¯†é’¥å­˜å‚¨åˆ°è¯·æ±‚å±æ€§ä¸­
            request.setAttribute("apiKey", apiKey);

            return true;

        } catch (Exception e) {
            log.error("API ç­¾åéªŒè¯å¤±è´¥", e);
            response.setStatus(HttpStatus.UNAUTHORIZED.value());
            response.getWriter().write("{\"code\": 401, \"message\": \"API ç­¾åéªŒè¯å¤±è´¥\"}");
            return false;
        }
    }

    private Map<String, String> extractParams(HttpServletRequest request) {
        Map<String, String> params = new HashMap<>();

        // æå– query params
        request.getParameterMap().forEach((key, values) -> {
            if (values.length > 0) {
                params.put(key, values[0]);
            }
        });

        // æå– body paramsï¼ˆä»…é™ POST/PUTï¼‰
        if (request.getMethod().equals("POST") || request.getMethod().equals("PUT")) {
            try {
                String body = new BufferedReader(new InputStreamReader(request.getInputStream()))
                    .lines().collect(Collectors.joining("\n"));
                if (StringUtils.hasText(body)) {
                    Map<String, Object> bodyParams = JSON.parseObject(body, Map.class);
                    bodyParams.forEach((key, value) -> {
                        if (value != null) {
                            params.put(key, value.toString());
                        }
                    });
                }
            } catch (IOException e) {
                log.warn("è§£æè¯·æ±‚ä½“å¤±è´¥", e);
            }
        }

        return params;
    }
}

/**
 * API è®¤è¯æœåŠ¡
 */
@Service
public class ApiAuthService {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    /**
     * è·å– API å¯†é’¥
     */
    public String getSecretKey(String apiKey) {
        // å…ˆä» Redis è·å–
        String secretKey = redisTemplate.opsForValue().get("api:secret:" + apiKey);
        if (secretKey != null) {
            return secretKey;
        }

        // ä»æ•°æ®åº“è·å–
        ApiCredential credential = apiCredentialMapper.selectByApiKey(apiKey);
        if (credential != null) {
            // ç¼“å­˜åˆ° Redis
            redisTemplate.opsForValue().set(
                "api:secret:" + apiKey,
                credential.getSecretKey(),
                1, TimeUnit.HOURS
            );
            return credential.getSecretKey();
        }

        return null;
    }

    /**
     * åˆ›å»º API å¯†é’¥
     */
    public ApiCredential createApiCredential(String name, Set<String> permissions) {
        String apiKey = generateApiKey();
        String secretKey = generateSecretKey();

        ApiCredential credential = new ApiCredential();
        credential.setApiKey(apiKey);
        credential.setSecretKey(secretKey);
        credential.setName(name);
        credential.setPermissions(permissions);
        credential.setStatus(1);
        credential.setCreateTime(new Date());

        apiCredentialMapper.insert(credential);

        // ç¼“å­˜åˆ° Redis
        redisTemplate.opsForValue().set(
            "api:secret:" + apiKey,
            secretKey,
            1, TimeUnit.HOURS
        );

        return credential;
    }

    private String generateApiKey() {
        return "bb_" + UUID.randomUUID().toString().replace("-", "");
    }

    private String generateSecretKey() {
        SecureRandom random = new SecureRandom();
        byte[] bytes = new byte[32];
        random.nextBytes(bytes);
        return Base64.getEncoder().encodeToString(bytes);
    }
}
```

### 2. æ¥å£é™æµé˜²æŠ¤

```java
/**
 * é™æµæ³¨è§£
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface RateLimit {

    /**
     * é™æµæ¬¡æ•°
     */
    int count() default 100;

    /**
     * æ—¶é—´çª—å£ï¼ˆç§’ï¼‰
     */
    int time() default 60;

    /**
     * é™æµç±»å‹
     */
    LimitType limitType() default LimitType.IP;

    /**
     * é™æµæç¤ºä¿¡æ¯
     */
    String message() default "è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•";
}

/**
 * é™æµç±»å‹æšä¸¾
 */
public enum LimitType {
    // æŒ‰ IP é™æµ
    IP,
    // æŒ‰ç”¨æˆ·é™æµ
    USER,
    // æŒ‰ API é™æµ
    API
}

/**
 * é™æµæœåŠ¡
 */
@Component
public class RateLimitService {

    private static final Logger log = LoggerFactory.getLogger(RateLimitService.class);

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    /**
     * æ£€æŸ¥æ˜¯å¦è¶…å‡ºé™æµ
     */
    public boolean isExceeded(String key, int count, int time) {
        String redisKey = "rate_limit:" + key;
        String luaScript =
            "local current = redis.call('GET', KEYS[1]) " +
            "if current == false then " +
            "  redis.call('SET', KEYS[1], 1) " +
            "  redis.call('EXPIRE', KEYS[1], ARGV[1]) " +
            "  return 0 " +
            "else " +
            "  local val = tonumber(current) " +
            "  if val >= tonumber(ARGV[2]) then " +
            "    return val " +
            "  else " +
            "    redis.call('INCR', KEYS[1]) " +
            "    return val + 1 " +
            "  end " +
            "end";

        DefaultRedisScript<Long> script = new DefaultRedisScript<>(luaScript, Long.class);
        Long result = redisTemplate.execute(script, Collections.singletonList(redisKey), time, String.valueOf(count));

        return result >= count;
    }

    /**
     * ç”Ÿæˆé™æµ key
     */
    public String generateKey(RateLimit rateLimit, HttpServletRequest request) {
        StringBuilder key = new StringBuilder();

        switch (rateLimit.limitType()) {
            case IP:
                key.append(getClientIp(request));
                break;
            case USER:
                key.append(getCurrentUserId(request));
                break;
            case API:
                key.append(request.getRequestURI());
                break;
        }

        return key.toString();
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xForwardedFor)) {
            return xForwardedFor.split(",")[0].trim();
        }
        String xRealIp = request.getHeader("X-Real-IP");
        if (StringUtils.hasText(xRealIp)) {
            return xRealIp;
        }
        return request.getRemoteAddr();
    }

    private String getCurrentUserId(HttpServletRequest request) {
        Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
        if (authentication != null && authentication.getPrincipal() instanceof User) {
            return ((User) authentication.getPrincipal()).getId().toString();
        }
        return "anonymous";
    }
}

/**
 * é™æµåˆ‡é¢
 */
@Aspect
@Component
public class RateLimitAspect {

    @Autowired
    private RateLimitService rateLimitService;

    @Around("@annotation(rateLimit)")
    public Object around(ProceedingJoinPoint point, RateLimit rateLimit) throws Throwable {
        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
        if (attributes == null) {
            return point.proceed();
        }

        HttpServletRequest request = attributes.getRequest();
        String key = rateLimitService.generateKey(rateLimit, request);

        if (rateLimitService.isExceeded(key, rateLimit.count(), rateLimit.time())) {
            throw new RateLimitExceededException(rateLimit.message());
        }

        return point.proceed();
    }
}

/**
 * ä½¿ç”¨é™æµçš„æ¥å£
 */
@RestController
@RequestMapping("/api/data")
public class DataController {

    @GetMapping("/query")
    @RateLimit(count = 50, time = 60, message = "æŸ¥è¯¢è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    public Result<List<Data>> queryData() {
        return Result.success(dataService.queryData());
    }

    @PostMapping("/export")
    @RateLimit(count = 5, time = 300, message = "å¯¼å‡ºè¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åå†è¯•")
    public Result<String> exportData() {
        return Result.success(dataService.exportData());
    }
}
```

---

## ğŸ“Š å®¡è®¡æ—¥å¿—å®ç°

### 1. æ“ä½œå®¡è®¡

```java
/**
 * å®¡è®¡æ—¥å¿—æ³¨è§£
 */
@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface AuditLog {

    /**
     * æ“ä½œç±»å‹
     */
    OperationType operation() default OperationType.QUERY;

    /**
     * æ“ä½œæè¿°
     */
    String description() default "";

    /**
     * æ˜¯å¦è®°å½•å‚æ•°
     */
    boolean recordParams() default true;

    /**
     * æ˜¯å¦è®°å½•ç»“æœ
     */
    boolean recordResult() default false;

    /**
     * æ•æ„Ÿå­—æ®µï¼ˆä¸è®°å½•ï¼‰
     */
    String[] sensitiveFields() default {};
}

/**
 * æ“ä½œç±»å‹æšä¸¾
 */
public enum OperationType {
    CREATE, READ, UPDATE, DELETE, LOGIN, LOGOUT, EXPORT, IMPORT
}

/**
 * å®¡è®¡æ—¥å¿—æœåŠ¡
 */
@Service
public class AuditLogService {

    private static final Logger auditLogger = LoggerFactory.getLogger("AUDIT_LOG");

    @Autowired
    private AuditLogMapper auditLogMapper;

    @Autowired
    private ElasticsearchRestTemplate elasticsearchRestTemplate;

    /**
     * è®°å½•å®¡è®¡æ—¥å¿—
     */
    public void recordAuditLog(AuditLogInfo logInfo) {
        try {
            // 1. å­˜å‚¨åˆ°æ•°æ®åº“
            auditLogMapper.insert(logInfo);

            // 2. å‘é€åˆ° Elasticsearch
            elasticsearchRestTemplate.save(logInfo);

            // 3. å†™å…¥æ–‡ä»¶æ—¥å¿—
            auditLogger.info(JSON.toJSONString(logInfo));

            // 4. å‘é€åˆ°æ¶ˆæ¯é˜Ÿåˆ—ï¼ˆå¼‚æ­¥å¤„ç†ï¼‰
            rocketMQTemplate.convertAndSend("audit_log_topic", logInfo);

        } catch (Exception e) {
            log.error("å®¡è®¡æ—¥å¿—è®°å½•å¤±è´¥", e);
        }
    }

    /**
     * è®°å½•ç”¨æˆ·ç™»å½•
     */
    public void recordLogin(Long userId, String username, String result, String reason) {
        AuditLogInfo logInfo = AuditLogInfo.builder()
            .operationType(OperationType.LOGIN)
            .operationDescription("ç”¨æˆ·ç™»å½•")
            .userId(userId)
            .username(username)
            .result(result)
            .reason(reason)
            .createTime(new Date())
            .build();

        recordAuditLog(logInfo);
    }

    /**
     * è®°å½•æ•°æ®å˜æ›´
     */
    public void recordDataChange(OperationType operation, String tableName,
                                Long userId, String username,
                                Object oldValue, Object newValue) {
        AuditLogInfo logInfo = AuditLogInfo.builder()
            .operationType(operation)
            .operationDescription("æ•°æ®å˜æ›´ - " + tableName)
            .tableName(tableName)
            .userId(userId)
            .username(username)
            .oldValue(maskSensitiveData(oldValue))
            .newValue(maskSensitiveData(newValue))
            .createTime(new Date())
            .build();

        recordAuditLog(logInfo);
    }

    /**
     * æŸ¥è¯¢å®¡è®¡æ—¥å¿—
     */
    public PageResult<AuditLogInfo> queryAuditLogs(AuditLogQueryRequest request) {
        return auditLogMapper.selectByCondition(request);
    }

    /**
     * å¯¼å‡ºå®¡è®¡æ—¥å¿—
     */
    public String exportAuditLogs(AuditLogQueryRequest request) {
        List<AuditLogInfo> logs = auditLogMapper.selectByConditionNoPage(request);
        return ExcelExportUtil.exportToExcel(logs);
    }

    private Object maskSensitiveData(Object data) {
        if (data == null) {
            return null;
        }

        // è„±æ•å¤„ç†
        if (data instanceof String) {
            String str = (String) data;
            if (str.contains("@")) {
                return str.replaceAll("(\\w{2})(\\w*)(\\w{1,})", "$1****@$3");
            }
            if (str.matches("\\d{11}")) {
                return str.replaceAll("(\\d{3})\\d{4}(\\d{4})", "$1****$2");
            }
        }

        return data;
    }

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class AuditLogInfo {
        private Long id;
        private OperationType operationType;
        private String operationDescription;
        private String tableName;
        private Long userId;
        private String username;
        private String clientIp;
        private String userAgent;
        private Object oldValue;
        private Object newValue;
        private String result;
        private String reason;
        private Date createTime;
    }
}

/**
 * å®¡è®¡æ—¥å¿—åˆ‡é¢
 */
@Aspect
@Component
public class AuditLogAspect {

    @Autowired
    private AuditLogService auditLogService;

    @Around("@annotation(auditLog)")
    public Object around(ProceedingJoinPoint point, AuditLog auditLog) throws Throwable {
        long startTime = System.currentTimeMillis();

        try {
            // è®°å½•æ“ä½œ
            Object result = point.proceed();

            long duration = System.currentTimeMillis() - startTime;

            // è®°å½•å®¡è®¡æ—¥å¿—
            recordAuditLog(auditLog, point, result, duration, true, null);

            return result;

        } catch (Throwable e) {
            long duration = System.currentTimeMillis() - startTime;
            recordAuditLog(auditLog, point, null, duration, false, e.getMessage());
            throw e;
        }
    }

    private void recordAuditLog(AuditLog auditLog, ProceedingJoinPoint point,
                               Object result, long duration, boolean success, String error) {
        try {
            MethodSignature signature = (MethodSignature) point.getSignature();
            Method method = signature.getMethod();

            // è·å–å½“å‰ç”¨æˆ·
            Authentication authentication = SecurityContextHolder.getContext().getAuthentication();
            User currentUser = null;
            if (authentication != null && authentication.getPrincipal() instanceof User) {
                currentUser = (User) authentication.getPrincipal();
            }

            // è·å–è¯·æ±‚ä¿¡æ¯
            ServletRequestAttributes attributes =
                (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            HttpServletRequest request = attributes.getRequest();

            AuditLogService.AuditLogInfo logInfo = AuditLogService.AuditLogInfo.builder()
                .operationType(auditLog.operation())
                .operationDescription(auditLog.description())
                .userId(currentUser != null ? currentUser.getId() : null)
                .username(currentUser != null ? currentUser.getUsername() : "system")
                .clientIp(getClientIp(request))
                .userAgent(request.getHeader("User-Agent"))
                .createTime(new Date())
                .build();

            if (auditLog.recordParams()) {
                // è®°å½•å‚æ•°ï¼ˆè„±æ•å¤„ç†ï¼‰
                Object[] args = point.getArgs();
                logInfo.setOldValue(maskSensitiveParams(signature.getParameterNames(), args));
            }

            if (auditLog.recordResult() && result != null) {
                logInfo.setNewValue(result);
            }

            if (!success) {
                logInfo.setResult("FAILURE");
                logInfo.setReason(error);
            } else {
                logInfo.setResult("SUCCESS");
            }

            auditLogService.recordAuditLog(logInfo);

        } catch (Exception e) {
            log.error("å®¡è®¡æ—¥å¿—è®°å½•å¤±è´¥", e);
        }
    }

    private String getClientIp(HttpServletRequest request) {
        String xForwardedFor = request.getHeader("X-Forwarded-For");
        if (StringUtils.hasText(xForwardedFor)) {
            return xForwardedFor.split(",")[0].trim();
        }
        return request.getRemoteAddr();
    }

    private Object maskSensitiveParams(String[] paramNames, Object[] args) {
        Map<String, Object> params = new HashMap<>();
        for (int i = 0; i < paramNames.length; i++) {
            String name = paramNames[i];
            Object value = args[i];
            if (value != null) {
                // è„±æ•æ•æ„Ÿå­—æ®µ
                params.put(name, maskValue(name, value));
            }
        }
        return params;
    }

    private Object maskValue(String name, Object value) {
        if (value instanceof String) {
            String str = (String) value;
            if (name.toLowerCase().contains("password") ||
                name.toLowerCase().contains("secret") ||
                name.toLowerCase().contains("token")) {
                return "***";
            }
        }
        return value;
    }
}

/**
 * å®¡è®¡æ—¥å¿—å®ä½“ç±»
 */
@Entity
@Table(name = "audit_log")
@Data
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AuditLogEntity implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Enumerated(EnumType.STRING)
    @Column(name = "operation_type", nullable = false)
    private OperationType operationType;

    @Column(name = "operation_desc", columnDefinition = "VARCHAR(255)")
    private String operationDescription;

    @Column(name = "table_name")
    private String tableName;

    @Column(name = "user_id")
    private Long userId;

    @Column(name = "username")
    private String username;

    @Column(name = "client_ip")
    private String clientIp;

    @Column(name = "user_agent", columnDefinition = "TEXT")
    private String userAgent;

    @Column(name = "old_value", columnDefinition = "LONGTEXT")
    private String oldValue;

    @Column(name = "new_value", columnDefinition = "LONGTEXT")
    private String newValue;

    @Column(name = "result")
    private String result;

    @Column(name = "reason")
    private String reason;

    @Column(name = "create_time")
    private Date createTime;

    @Column(name = "trace_id")
    private String traceId;
}
```

### 2. æ•°æ®è¡€ç¼˜è¿½è¸ª

```java
/**
 * æ•°æ®è¡€ç¼˜æœåŠ¡
 */
@Service
public class DataLineageService {

    /**
     * è®°å½•æ•°æ®æ¥æº
     */
    public void recordDataSource(String tableName, String fieldName, String sourceTable,
                                String sourceField, String transformRule, Long operatorId) {
        DataLineageRecord record = DataLineageRecord.builder()
            .tableName(tableName)
            .fieldName(fieldName)
            .sourceTable(sourceTable)
            .sourceField(sourceField)
            .transformRule(transformRule)
            .operatorId(operatorId)
            .createTime(new Date())
            .build();

        dataLineageMapper.insert(record);
    }

    /**
     * æŸ¥è¯¢æ•°æ®è¡€ç¼˜å…³ç³»
     */
    public List<DataLineageRecord> getDataLineage(String tableName) {
        return dataLineageMapper.selectByTableName(tableName);
    }

    /**
     * ç”Ÿæˆæ•°æ®è¡€ç¼˜å›¾
     */
    public DataLineageGraph generateLineageGraph(String tableName) {
        List<DataLineageRecord> records = getDataLineage(tableName);
        return buildLineageGraph(records);
    }

    private DataLineageGraph buildLineageGraph(List<DataLineageRecord> records) {
        DataLineageGraph graph = new DataLineageGraph();
        records.forEach(record -> {
            Node sourceNode = new Node(record.getSourceTable(), record.getSourceField());
            Node targetNode = new Node(record.getTableName(), record.getFieldName());
            Edge edge = new Edge(sourceNode, targetNode, record.getTransformRule());

            graph.addEdge(edge);
        });
        return graph;
    }

    @Data
    @Builder
    @AllArgsConstructor
    @NoArgsConstructor
    public static class DataLineageRecord {
        private Long id;
        private String tableName;
        private String fieldName;
        private String sourceTable;
        private String sourceField;
        private String transformRule;
        private Long operatorId;
        private Date createTime;
    }

    @Data
    @AllArgsConstructor
    public static class Node {
        private String table;
        private String field;
    }

    @Data
    @AllArgsConstructor
    public static class Edge {
        private Node source;
        private Node target;
        private String transformRule;
    }

    @Getter
    @AllArgsConstructor
    public static class DataLineageGraph {
        private List<Edge> edges = new ArrayList<>();

        public void addEdge(Edge edge) {
            edges.add(edge);
        }
    }
}
```

---

## ğŸš¨ å®‰å…¨ç›‘æ§ä¸å‘Šè­¦

### 1. å®‰å…¨äº‹ä»¶ç›‘æ§

```java
/**
 * å®‰å…¨äº‹ä»¶ç›‘æ§
 */
@Component
public class SecurityEventMonitor {

    private static final Logger log = LoggerFactory.getLogger(SecurityEventMonitor.class);

    @Autowired
    private AlertService alertService;

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    /**
     * ç›‘æ§å¼‚å¸¸ç™»å½•
     */
    @EventListener
    public void handleAbnormalLogin(AbnormalLoginEvent event) {
        String userId = event.getUserId();
        String clientIp = event.getClientIp();
        String reason = event.getReason();

        // æ£€æŸ¥æ˜¯å¦åœ¨é»‘åå•ä¸­
        if (isInBlacklist(clientIp)) {
            alertService.sendSecurityAlert("IP é»‘åå•ç™»å½•å°è¯•: " + clientIp);
        }

        // æ£€æŸ¥ç™»å½•é¢‘ç‡
        checkLoginFrequency(userId, clientIp);

        // æ£€æŸ¥åœ°ç†ä½ç½®
        checkLoginLocation(userId, event.getLocation());

        log.warn("å¼‚å¸¸ç™»å½•äº‹ä»¶: userId={}, clientIp={}, reason={}", userId, clientIp, reason);
    }

    /**
     * ç›‘æ§æƒé™æå‡å°è¯•
     */
    @EventListener
    public void handlePrivilegeEscalation(PrivilegeEscalationEvent event) {
        String userId = event.getUserId();
        String fromRole = event.getFromRole();
        String toRole = event.getToRole();

        alertService.sendSecurityAlert("æƒé™æå‡å°è¯•: userId=" + userId +
            ", from=" + fromRole + ", to=" + toRole);

        log.error("æƒé™æå‡äº‹ä»¶: userId={}, fromRole={}, toRole={}",
            userId, fromRole, toRole);
    }

    /**
     * ç›‘æ§æ•æ„Ÿæ•°æ®è®¿é—®
     */
    @EventListener
    public void handleSensitiveDataAccess(SensitiveDataAccessEvent event) {
        String userId = event.getUserId();
        String tableName = event.getTableName();
        String operation = event.getOperation();

        // è®°å½•æ•æ„Ÿæ“ä½œ
        if (isHighRiskOperation(operation)) {
            alertService.sendSecurityAlert("æ•æ„Ÿæ•°æ®è®¿é—®: userId=" + userId +
                ", table=" + tableName + ", operation=" + operation);
        }

        log.info("æ•æ„Ÿæ•°æ®è®¿é—®: userId={}, tableName={}, operation={}",
            userId, tableName, operation);
    }

    /**
     * ç›‘æ§ API è®¿é—®é¢‘ç‡
     */
    public void checkApiAccessRate(String apiKey, String clientIp) {
        String key = "api:access:" + apiKey + ":" + clientIp;
        Long count = redisTemplate.opsForValue().increment(key, 1);

        if (count == 1) {
            redisTemplate.expire(key, 3600, TimeUnit.SECONDS);
        }

        if (count > 1000) { // æ¯å°æ—¶è¶…è¿‡ 1000 æ¬¡
            alertService.sendSecurityAlert("API è®¿é—®é¢‘ç‡è¿‡é«˜: apiKey=" + apiKey +
                ", count=" + count);
        }
    }

    private boolean isInBlacklist(String ip) {
        return Boolean.TRUE.equals(redisTemplate.hasKey("blacklist:" + ip));
    }

    private void checkLoginFrequency(String userId, String clientIp) {
        String key = "login:attempt:" + userId + ":" + clientIp;
        Long attempts = redisTemplate.opsForValue().increment(key, 1);

        if (attempts == 1) {
            redisTemplate.expire(key, 900, TimeUnit.SECONDS); // 15 åˆ†é’Ÿ
        }

        if (attempts > 10) {
            alertService.sendSecurityAlert("ç™»å½•å°è¯•æ¬¡æ•°è¿‡å¤š: userId=" + userId +
                ", attempts=" + attempts);
        }
    }

    private void checkLoginLocation(String userId, String location) {
        // æ£€æŸ¥ç”¨æˆ·å¸¸ç”¨ç™»å½•åœ°ç‚¹
        String lastLocationKey = "login:last_location:" + userId;
        String lastLocation = redisTemplate.opsForValue().get(lastLocationKey);

        if (lastLocation != null && !lastLocation.equals(location)) {
            alertService.sendSecurityAlert("å¼‚å¸¸ç™»å½•åœ°ç‚¹: userId=" + userId +
                ", last=" + lastLocation + ", current=" + location);
        }

        redisTemplate.opsForValue().set(lastLocationKey, location, 30, TimeUnit.DAYS);
    }

    private boolean isHighRiskOperation(String operation) {
        return Arrays.asList("DELETE", "EXPORT", "BULK_UPDATE").contains(operation);
    }
}

/**
 * å®‰å…¨å‘Šè­¦æœåŠ¡
 */
@Service
public class AlertService {

    @Autowired
    private EmailService emailService;

    @Autowired
    private SmsService smsService;

    @Autowired
    private DingTalkService dingTalkService;

    public void sendSecurityAlert(String message) {
        // 1. å‘é€é‚®ä»¶
        emailService.sendSecurityAlert(message);

        // 2. å‘é€çŸ­ä¿¡ï¼ˆä¸¥é‡å‘Šè­¦ï¼‰
        if (isSevereAlert(message)) {
            smsService.sendSecurityAlert(message);
        }

        // 3. å‘é€é’‰é’‰é€šçŸ¥
        dingTalkService.sendSecurityAlert(message);

        // 4. å†™å…¥å‘Šè­¦æ—¥å¿—
        log.error("å®‰å…¨å‘Šè­¦: {}", message);
    }

    private boolean isSevereAlert(String message) {
        return message.contains("æƒé™æå‡") ||
               message.contains("SQL æ³¨å…¥") ||
               message.contains("æ•°æ®æ³„éœ²");
    }
}
```

### 2. å®‰å…¨å®¡è®¡æŠ¥å‘Š

```java
/**
 * å®‰å…¨å®¡è®¡æŠ¥å‘Šç”Ÿæˆ
 */
@Service
public class SecurityAuditReportService {

    @Autowired
    private AuditLogMapper auditLogMapper;

    @Autowired
    private UserBehaviorAnalysisMapper behaviorMapper;

    /**
     * ç”Ÿæˆå®‰å…¨å®¡è®¡æŠ¥å‘Š
     */
    public SecurityAuditReport generateReport(Date startDate, Date endDate) {
        SecurityAuditReport report = new SecurityAuditReport();
        report.setPeriod(startDate, endDate);

        // 1. ç™»å½•å®‰å…¨ç»Ÿè®¡
        LoginSecurityStats loginStats = analyzeLoginSecurity(startDate, endDate);
        report.setLoginStats(loginStats);

        // 2. æƒé™ä½¿ç”¨ç»Ÿè®¡
        PrivilegeUsageStats privilegeStats = analyzePrivilegeUsage(startDate, endDate);
        report.setPrivilegeStats(privilegeStats);

        // 3. æ•æ„Ÿæ“ä½œç»Ÿè®¡
        SensitiveOperationStats sensitiveStats = analyzeSensitiveOperations(startDate, endDate);
        report.setSensitiveStats(sensitiveStats);

        // 4. ç”¨æˆ·è¡Œä¸ºåˆ†æ
        UserBehaviorStats behaviorStats = analyzeUserBehavior(startDate, endDate);
        report.setBehaviorStats(behaviorStats);

        // 5. å®‰å…¨å¨èƒåˆ†æ
        ThreatAnalysis threatAnalysis = analyzeThreats(startDate, endDate);
        report.setThreatAnalysis(threatAnalysis);

        return report;
    }

    private LoginSecurityStats analyzeLoginSecurity(Date startDate, Date endDate) {
        LoginSecurityStats stats = new LoginSecurityStats();

        // å¤±è´¥ç™»å½•æ¬¡æ•°
        stats.setFailedLoginCount(auditLogMapper.countFailedLogins(startDate, endDate));

        // å¼‚å¸¸ IP ç™»å½•æ¬¡æ•°
        stats.setAbnormalIpLoginCount(auditLogMapper.countAbnormalIpLogins(startDate, endDate));

        // å¼‚åœ°ç™»å½•æ¬¡æ•°
        stats.setRemoteLoginCount(auditLogMapper.countRemoteLogins(startDate, endDate));

        // æš´åŠ›ç ´è§£å°è¯•
        stats.setBruteForceAttempts(auditLogMapper.countBruteForceAttempts(startDate, endDate));

        return stats;
    }

    private PrivilegeUsageStats analyzePrivilegeUsage(Date startDate, Date endDate) {
        PrivilegeUsageStats stats = new PrivilegeUsageStats();

        // è§’è‰²ä½¿ç”¨æƒ…å†µ
        List<RoleUsage> roleUsages = auditLogMapper.getRoleUsageStats(startDate, endDate);
        stats.setRoleUsages(roleUsages);

        // é«˜å±æ“ä½œæ‰§è¡Œæƒ…å†µ
        List<HighRiskOperation> highRiskOps = auditLogMapper.getHighRiskOperations(startDate, endDate);
        stats.setHighRiskOperations(highRiskOps);

        return stats;
    }

    private SensitiveOperationStats analyzeSensitiveOperations(Date startDate, Date endDate) {
        SensitiveOperationStats stats = new SensitiveOperationStats();

        // æ•æ„Ÿè¡¨è®¿é—®ç»Ÿè®¡
        List<SensitiveTableAccess> tableAccesses = auditLogMapper.getSensitiveTableAccess(startDate, endDate);
        stats.setTableAccesses(tableAccesses);

        // æ•°æ®å¯¼å‡ºç»Ÿè®¡
        List<DataExport> exports = auditLogMapper.getDataExports(startDate, endDate);
        stats.setDataExports(exports);

        return stats;
    }

    private UserBehaviorStats analyzeUserBehavior(Date startDate, Date endDate) {
        UserBehaviorStats stats = new UserBehaviorStats();

        // æ´»è·ƒç”¨æˆ·
        List<ActiveUser> activeUsers = behaviorMapper.getActiveUsers(startDate, endDate);
        stats.setActiveUsers(activeUsers);

        // å¼‚å¸¸è¡Œä¸ºç”¨æˆ·
        List<AnomalousUser> anomalousUsers = behaviorMapper.getAnomalousUsers(startDate, endDate);
        stats.setAnomalousUsers(anomalousUsers);

        return stats;
    }

    private ThreatAnalysis analyzeThreats(Date startDate, Date endDate) {
        ThreatAnalysis analysis = new ThreatAnalysis();

        // SQL æ³¨å…¥æ”»å‡»
        analysis.setSqlInjectionAttempts(auditLogMapper.countSqlInjectionAttempts(startDate, endDate));

        // XSS æ”»å‡»
        analysis.setXssAttempts(auditLogMapper.countXssAttempts(startDate, endDate));

        // CSRF æ”»å‡»
        analysis.setCsrfAttempts(auditLogMapper.countCsrfAttempts(startDate, endDate));

        return analysis;
    }

    /**
     * å¯¼å‡ºæŠ¥å‘Šåˆ° PDF
     */
    public String exportReportToPdf(SecurityAuditReport report) {
        try {
            String fileName = "security_audit_report_" + System.currentTimeMillis() + ".pdf";
            String filePath = "/tmp/" + fileName;

            Document document = new Document(PageSize.A4);
            PdfWriter.getInstance(document, new FileOutputStream(filePath));

            document.open();

            // æ·»åŠ æ ‡é¢˜
            document.add(new Paragraph("å®‰å…¨å®¡è®¡æŠ¥å‘Š", FontFactory.getFont(FontFactory.HELVETICA_BOLD, 18)));

            // æ·»åŠ æ—¶é—´æ®µ
            document.add(new Paragraph("æŠ¥å‘Šå‘¨æœŸ: " +
                DateFormatUtils.format(report.getStartDate(), "yyyy-MM-dd") + " è‡³ " +
                DateFormatUtils.format(report.getEndDate(), "yyyy-MM-dd")));

            // æ·»åŠ å„éƒ¨åˆ†ç»Ÿè®¡ä¿¡æ¯
            addLoginStatsSection(document, report.getLoginStats());
            addPrivilegeStatsSection(document, report.getPrivilegeStats());
            addSensitiveStatsSection(document, report.getSensitiveStats());
            addBehaviorStatsSection(document, report.getBehaviorStats());
            addThreatAnalysisSection(document, report.getThreatAnalysis());

            document.close();

            return filePath;
        } catch (Exception e) {
            throw new RuntimeException("æŠ¥å‘Šå¯¼å‡ºå¤±è´¥", e);
        }
    }

    private void addLoginStatsSection(Document document, LoginSecurityStats stats) throws DocumentException {
        document.add(new Paragraph("ç™»å½•å®‰å…¨ç»Ÿè®¡", FontFactory.getFont(FontFactory.HELVETICA_BOLD, 14)));
        document.add(new Paragraph("å¤±è´¥ç™»å½•æ¬¡æ•°: " + stats.getFailedLoginCount()));
        document.add(new Paragraph("å¼‚å¸¸IPç™»å½•æ¬¡æ•°: " + stats.getAbnormalIpLoginCount()));
        document.add(new Paragraph("å¼‚åœ°ç™»å½•æ¬¡æ•°: " + stats.getRemoteLoginCount()));
        document.add(new Paragraph("æš´åŠ›ç ´è§£å°è¯•: " + stats.getBruteForceAttempts()));
        document.add(Chunk.NEWLINE);
    }

    // ... å…¶ä»–ç« èŠ‚ç±»ä¼¼å®ç°
}
```

---

## ğŸ§ª å®‰å…¨æµ‹è¯•

### 1. å®‰å…¨æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash
# ===================================================================
# å®‰å…¨æµ‹è¯•è„šæœ¬
# ===================================================================

set -e

# é¢œè‰²å®šä¹‰
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

# æµ‹è¯•é…ç½®
BASE_URL="http://localhost:8080"
API_KEY="your_api_key"
SECRET_KEY="your_secret_key"

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# æµ‹è¯• JWT Token
test_jwt_auth() {
    log_info "æµ‹è¯• JWT Token è®¤è¯..."

    # è·å– Token
    response=$(curl -s -X POST "$BASE_URL/api/auth/login" \
        -H "Content-Type: application/json" \
        -d '{"username":"admin","password":"123456"}')

    token=$(echo $response | jq -r '.data.token')

    if [ "$token" == "null" ] || [ -z "$token" ]; then
        log_error "Token è·å–å¤±è´¥"
        return 1
    fi

    log_info "Token è·å–æˆåŠŸ: ${token:0:20}..."

    # ä½¿ç”¨ Token è®¿é—®æ¥å£
    response=$(curl -s -X GET "$BASE_URL/api/user/profile" \
        -H "Authorization: Bearer $token")

    if echo "$response" | jq -e '.code == 0' > /dev/null; then
        log_info "JWT Token è®¤è¯æµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "JWT Token è®¤è¯æµ‹è¯•å¤±è´¥"
        return 1
    fi
}

# æµ‹è¯• API ç­¾å
test_api_signature() {
    log_info "æµ‹è¯• API ç­¾å..."

    timestamp=$(date +%s)
    nonce=$(openssl rand -hex 16)
    method="GET"
    uri="/api/data/query"
    params='{"param1":"value1"}'

    # ç”Ÿæˆç­¾å
    signature=$(echo -n "$method\n$uri\n$params\n$timestamp\n$nonce" | \
        openssl dgst -sha256 -hmac "$SECRET_KEY" | cut -d' ' -f2 | base64)

    # å‘é€è¯·æ±‚
    response=$(curl -s -X GET "$BASE_URL$uri?param1=value1" \
        -H "X-API-Key: $API_KEY" \
        -H "X-API-Signature: $signature" \
        -H "X-API-Timestamp: $timestamp" \
        -H "X-API-Nonce: $nonce")

    if echo "$response" | jq -e '.code == 0' > /dev/null; then
        log_info "API ç­¾åæµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "API ç­¾åæµ‹è¯•å¤±è´¥"
        return 1
    fi
}

# æµ‹è¯•æƒé™æ§åˆ¶
test_authorization() {
    log_info "æµ‹è¯•æƒé™æ§åˆ¶..."

    # ä½¿ç”¨æ™®é€šç”¨æˆ· Token è®¿é—®ç®¡ç†å‘˜æ¥å£
    response=$(curl -s -X GET "$BASE_URL/api/admin/users" \
        -H "Authorization: Bearer $USER_TOKEN" \
        -w "\nHTTP_CODE:%{http_code}")

    http_code=$(echo "$response" | grep "HTTP_CODE" | cut -d':' -f2)

    if [ "$http_code" == "403" ]; then
        log_info "æƒé™æ§åˆ¶æµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "æƒé™æ§åˆ¶æµ‹è¯•å¤±è´¥ï¼ŒæœŸæœ› 403ï¼Œå®é™… $http_code"
        return 1
    fi
}

# æµ‹è¯• SQL æ³¨å…¥
test_sql_injection() {
    log_info "æµ‹è¯• SQL æ³¨å…¥é˜²æŠ¤..."

    # å°è¯• SQL æ³¨å…¥
    response=$(curl -s -X GET "$BASE_URL/api/user/search?name=admin' OR '1'='1" \
        -H "Authorization: Bearer $ADMIN_TOKEN")

    if echo "$response" | jq -e '.code != 0' > /dev/null; then
        log_info "SQL æ³¨å…¥é˜²æŠ¤æµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "SQL æ³¨å…¥é˜²æŠ¤æµ‹è¯•å¤±è´¥"
        return 1
    fi
}

# æµ‹è¯• XSS é˜²æŠ¤
test_xss() {
    log_info "æµ‹è¯• XSS é˜²æŠ¤..."

    # å°è¯• XSS æ”»å‡»
    response=$(curl -s -X POST "$BASE_URL/api/comment" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $USER_TOKEN" \
        -d '{"content":"<script>alert(1)</script>"}' \
        -w "\nHTTP_CODE:%{http_code}")

    http_code=$(echo "$response" | grep "HTTP_CODE" | cut -d':' -f2)

    if [ "$http_code" == "400" ] || [ "$http_code" == "403" ]; then
        log_info "XSS é˜²æŠ¤æµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "XSS é˜²æŠ¤æµ‹è¯•å¤±è´¥ï¼ŒæœŸæœ› 400/403ï¼Œå®é™… $http_code"
        return 1
    fi
}

# æµ‹è¯•æ•æ„Ÿæ•°æ®åŠ å¯†
test_data_encryption() {
    log_info "æµ‹è¯•æ•æ„Ÿæ•°æ®åŠ å¯†..."

    # è®¿é—®åŒ…å«æ•æ„Ÿä¿¡æ¯çš„æ¥å£
    response=$(curl -s -X GET "$BASE_URL/api/user/profile" \
        -H "Authorization: Bearer $ADMIN_TOKEN")

    # æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«æ˜æ–‡æ•æ„Ÿä¿¡æ¯
    if echo "$response" | grep -E '[0-9]{15,18}' | grep -v '"phone"' > /dev/null; then
        log_error "æ£€æµ‹åˆ°æ˜æ–‡èº«ä»½è¯å·ï¼Œæ•æ„Ÿæ•°æ®æœªåŠ å¯†"
        return 1
    fi

    if echo "$response" | grep -E '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}' | grep -v '"email"' > /dev/null; then
        log_error "æ£€æµ‹åˆ°æ˜æ–‡é‚®ç®±ï¼Œæ•æ„Ÿæ•°æ®æœªåŠ å¯†"
        return 1
    fi

    log_info "æ•æ„Ÿæ•°æ®åŠ å¯†æµ‹è¯•é€šè¿‡"
    return 0
}

# æµ‹è¯•å®¡è®¡æ—¥å¿—
test_audit_log() {
    log_info "æµ‹è¯•å®¡è®¡æ—¥å¿—è®°å½•..."

    # æ‰§è¡Œä¸€ä¸ªæ“ä½œ
    curl -s -X POST "$BASE_URL/api/user" \
        -H "Content-Type: application/json" \
        -H "Authorization: Bearer $ADMIN_TOKEN" \
        -d '{"username":"test","password":"123456"}' > /dev/null

    # æŸ¥è¯¢å®¡è®¡æ—¥å¿—
    response=$(curl -s -X GET "$BASE_URL/api/audit/logs?operation=CREATE&table=sys_user" \
        -H "Authorization: Bearer $ADMIN_TOKEN")

    if echo "$response" | jq -e '.data.total > 0' > /dev/null; then
        log_info "å®¡è®¡æ—¥å¿—æµ‹è¯•é€šè¿‡"
        return 0
    else
        log_error "å®¡è®¡æ—¥å¿—æµ‹è¯•å¤±è´¥"
        return 1
    fi
}

# å‹åŠ›æµ‹è¯•å®‰å…¨æ¥å£
test_security_load() {
    log_info "æ‰§è¡Œå®‰å…¨æ¥å£å‹åŠ›æµ‹è¯•..."

    # å¹¶å‘æµ‹è¯•ç™»å½•æ¥å£
    for i in {1..10}; do
        curl -s -X POST "$BASE_URL/api/auth/login" \
            -H "Content-Type: application/json" \
            -d '{"username":"admin","password":"123456"}' &
    done

    wait

    log_info "å‹åŠ›æµ‹è¯•å®Œæˆ"
    return 0
}

# ä¸»å‡½æ•°
main() {
    log_info "å¼€å§‹å®‰å…¨æµ‹è¯•..."

    # åˆå§‹åŒ–æµ‹è¯•
    test_jwt_auth || exit 1
    test_api_signature || exit 1

    # æƒé™æµ‹è¯•
    test_authorization || exit 1

    # å®‰å…¨é˜²æŠ¤æµ‹è¯•
    test_sql_injection || exit 1
    test_xss || exit 1

    # æ•°æ®å®‰å…¨æµ‹è¯•
    test_data_encryption || exit 1

    # å®¡è®¡æµ‹è¯•
    test_audit_log || exit 1

    # æ€§èƒ½æµ‹è¯•
    test_security_load || exit 1

    log_info "æ‰€æœ‰å®‰å…¨æµ‹è¯•é€šè¿‡ï¼"
}

main "$@"
```

### 2. Python å®‰å…¨æµ‹è¯•

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

"""
å®‰å…¨æµ‹è¯•è‡ªåŠ¨åŒ–è„šæœ¬
"""

import requests
import json
import time
import hashlib
import hmac
import base64
from datetime import datetime

class SecurityTester:
    def __init__(self, base_url, api_key, secret_key):
        self.base_url = base_url
        self.api_key = api_key
        self.secret_key = secret_key
        self.session = requests.Session()
        self.token = None

    def test_jwt_authentication(self):
        """æµ‹è¯• JWT è®¤è¯"""
        print("[INFO] æµ‹è¯• JWT è®¤è¯...")

        # ç™»å½•è·å– Token
        login_data = {
            "username": "admin",
            "password": "123456"
        }

        response = self.session.post(
            f"{self.base_url}/api/auth/login",
            json=login_data
        )

        if response.status_code == 200:
            result = response.json()
            if result.get("code") == 0:
                self.token = result.get("data", {}).get("token")
                print(f"[SUCCESS] JWT Token è·å–æˆåŠŸ")
                return True

        print("[ERROR] JWT è®¤è¯å¤±è´¥")
        return False

    def test_api_signature(self):
        """æµ‹è¯• API ç­¾å"""
        print("[INFO] æµ‹è¯• API ç­¾å...")

        timestamp = str(int(time.time()))
        nonce = "test123"
        method = "GET"
        uri = "/api/data/query"
        params = {"param1": "value1"}

        # ç”Ÿæˆç­¾åå­—ç¬¦ä¸²
        sign_str = f"{method}\n{uri}\n{json.dumps(params, sort_keys=True)}\n{timestamp}\n{nonce}"

        # è®¡ç®— HMAC-SHA256 ç­¾å
        signature = base64.b64encode(
            hmac.new(
                self.secret_key.encode('utf-8'),
                sign_str.encode('utf-8'),
                hashlib.sha256
            ).digest()
        ).decode('utf-8')

        # å‘é€è¯·æ±‚
        headers = {
            "X-API-Key": self.api_key,
            "X-API-Signature": signature,
            "X-API-Timestamp": timestamp,
            "X-API-Nonce": nonce
        }

        response = self.session.get(
            f"{self.base_url}{uri}",
            params=params,
            headers=headers
        )

        if response.status_code == 200:
            print("[SUCCESS] API ç­¾åéªŒè¯é€šè¿‡")
            return True

        print("[ERROR] API ç­¾åéªŒè¯å¤±è´¥")
        return False

    def test_sql_injection(self):
        """æµ‹è¯• SQL æ³¨å…¥é˜²æŠ¤"""
        print("[INFO] æµ‹è¯• SQL æ³¨å…¥é˜²æŠ¤...")

        # å°è¯• SQL æ³¨å…¥æ”»å‡»
        sql_injection_payloads = [
            "' OR '1'='1",
            "admin'; DROP TABLE users; --",
            "1' UNION SELECT password FROM users --",
            "' OR 1=1#"
        ]

        for payload in sql_injection_payloads:
            response = self.session.get(
                f"{self.base_url}/api/user/search",
                params={"name": payload}
            )

            if response.status_code != 400:
                print(f"[WARNING] SQL æ³¨å…¥é˜²æŠ¤å¯èƒ½å­˜åœ¨æ¼æ´: {payload}")

        print("[INFO] SQL æ³¨å…¥é˜²æŠ¤æµ‹è¯•å®Œæˆ")
        return True

    def test_xss_protection(self):
        """æµ‹è¯• XSS é˜²æŠ¤"""
        print("[INFO] æµ‹è¯• XSS é˜²æŠ¤...")

        xss_payloads = [
            "<script>alert('XSS')</script>",
            "javascript:alert('XSS')",
            "<img src=x onerror=alert('XSS')>",
            "<svg onload=alert('XSS')>"
        ]

        for payload in xss_payloads:
            response = self.session.post(
                f"{self.base_url}/api/comment",
                json={"content": payload}
            )

            # æ£€æŸ¥å“åº”ä¸­æ˜¯å¦åŒ…å«æœªè½¬ä¹‰çš„è„šæœ¬
            if payload in response.text:
                print(f"[ERROR] XSS é˜²æŠ¤å¤±è´¥: {payload}")
                return False

        print("[SUCCESS] XSS é˜²æŠ¤æµ‹è¯•é€šè¿‡")
        return True

    def test_rate_limiting(self):
        """æµ‹è¯•é™æµæœºåˆ¶"""
        print("[INFO] æµ‹è¯•é™æµæœºåˆ¶...")

        # å¿«é€Ÿå‘é€å¤šä¸ªè¯·æ±‚
        for i in range(10):
            response = self.session.get(f"{self.base_url}/api/data/query")

            if response.status_code == 429:
                print(f"[SUCCESS] é™æµæœºåˆ¶ç”Ÿæ•ˆ")
                return True

        print("[WARNING] æœªæ£€æµ‹åˆ°é™æµæœºåˆ¶")
        return False

    def test_data_encryption(self):
        """æµ‹è¯•æ•°æ®åŠ å¯†"""
        print("[INFO] æµ‹è¯•æ•°æ®åŠ å¯†...")

        headers = {"Authorization": f"Bearer {self.token}"}
        response = self.session.get(
            f"{self.base_url}/api/user/profile",
            headers=headers
        )

        if response.status_code == 200:
            data = response.json()

            # æ£€æŸ¥æ•æ„Ÿå­—æ®µæ˜¯å¦åŠ å¯†
            if "data" in data:
                user_info = data["data"]
                if "phone" in user_info and not user_info["phone"].startswith("ENC("):
                    print("[ERROR] æ•æ„Ÿæ•°æ®æœªåŠ å¯†")
                    return False

                if "email" in user_info and not user_info["email"].startswith("ENC("):
                    print("[ERROR] æ•æ„Ÿæ•°æ®æœªåŠ å¯†")
                    return False

        print("[SUCCESS] æ•°æ®åŠ å¯†æµ‹è¯•é€šè¿‡")
        return True

    def run_all_tests(self):
        """è¿è¡Œæ‰€æœ‰æµ‹è¯•"""
        print("=" * 50)
        print("å®‰å…¨æµ‹è¯•å¼€å§‹")
        print("=" * 50)

        tests = [
            ("JWT è®¤è¯", self.test_jwt_authentication),
            ("API ç­¾å", self.test_api_signature),
            ("SQL æ³¨å…¥é˜²æŠ¤", self.test_sql_injection),
            ("XSS é˜²æŠ¤", self.test_xss_protection),
            ("é™æµæœºåˆ¶", self.test_rate_limiting),
            ("æ•°æ®åŠ å¯†", self.test_data_encryption)
        ]

        passed = 0
        failed = 0

        for test_name, test_func in tests:
            print(f"\n{'=' * 20} {test_name} {'=' * 20}")
            try:
                if test_func():
                    passed += 1
                else:
                    failed += 1
            except Exception as e:
                print(f"[ERROR] æµ‹è¯•å¼‚å¸¸: {e}")
                failed += 1

        print("\n" + "=" * 50)
        print(f"æµ‹è¯•ç»“æœ: {passed} é€šè¿‡, {failed} å¤±è´¥")
        print("=" * 50)

if __name__ == "__main__":
    tester = SecurityTester(
        base_url="http://localhost:8080",
        api_key="your_api_key",
        secret_key="your_secret_key"
    )
    tester.run_all_tests()
```

---

## ğŸ“š å‚è€ƒèµ„æ–™

1. [OWASP å®‰å…¨ç¼–ç è§„èŒƒ](https://owasp.org/www-project-secure-coding-practices-quick-reference-guide/)
2. [Spring Security å®˜æ–¹æ–‡æ¡£](https://docs.spring.io/spring-security/reference/)
3. [JWT æ ‡å‡†è§„èŒƒ](https://datatracker.ietf.org/doc/html/rfc7519)
4. [OAuth 2.0 æˆæƒæ¡†æ¶](https://datatracker.ietf.org/doc/html/rfc6749)
5. [HTTPS/TLS å®‰å…¨æœ€ä½³å®è·µ](https://wiki.mozilla.org/Security/Server_Side_TLS)

---

## ğŸ“‹ å®‰å…¨æ£€æŸ¥æ¸…å•

### è®¤è¯å®‰å…¨
- [ ] å¼ºåˆ¶ä½¿ç”¨ HTTPS
- [ ] JWT Token è®¾ç½®åˆç†è¿‡æœŸæ—¶é—´
- [ ] å¯†ç ä½¿ç”¨ BCrypt åŠ å¯†
- [ ] å¤šå› ç´ è®¤è¯ (MFA) å¯ç”¨
- [ ] é˜²æ­¢æš´åŠ›ç ´è§£æ”»å‡»
- [ ] Session ç®¡ç†å®‰å…¨

### æ•°æ®å®‰å…¨
- [ ] æ•æ„Ÿæ•°æ®åŠ å¯†å­˜å‚¨
- [ ] æ•°æ®åº“è¿æ¥åŠ å¯†
- [ ] æ•°æ®ä¼ è¾“åŠ å¯† (TLS 1.3)
- [ ] æ•°æ®è„±æ•æ˜¾ç¤º
- [ ] æ•°æ®å¤‡ä»½åŠ å¯†

### æ¥å£å®‰å…¨
- [ ] API ç­¾åéªŒè¯
- [ ] é˜²é‡æ”¾æ”»å‡»
- [ ] æ¥å£é™æµ
- [ ] å‚æ•°æ ¡éªŒ
- [ ] SQL æ³¨å…¥é˜²æŠ¤
- [ ] XSS é˜²æŠ¤
- [ ] CSRF é˜²æŠ¤

### å®¡è®¡æ—¥å¿—
- [ ] æ“ä½œæ—¥å¿—è®°å½•
- [ ] ç™»å½•æ—¥å¿—è®°å½•
- [ ] æ•æ„Ÿæ“ä½œå®¡è®¡
- [ ] æ—¥å¿—å®Œæ•´æ€§ä¿è¯
- [ ] æ—¥å¿—ç›‘æ§å‘Šè­¦

---

**ç¼–åˆ¶ï¼š** æµ®æµ®é…± ğŸ±ï¼ˆçŒ«å¨˜å·¥ç¨‹å¸ˆï¼‰
**æ—¥æœŸï¼š** 2025-11-14
**çŠ¶æ€ï¼š** ğŸ“‹ æŒ‡å—å®Œæˆï¼Œå‡†å¤‡å®æ–½

**åŠ æ²¹å–µï½ ç³»ç»Ÿå®‰å…¨åŠ å›ºå³å°†å®Œæˆï¼** à¸…'Ï‰'à¸…
